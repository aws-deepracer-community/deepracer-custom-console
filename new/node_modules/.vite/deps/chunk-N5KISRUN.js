import {
  throttle
} from "./chunk-FTHEUEP7.js";
import {
  custom_css_properties_default
} from "./chunk-OLLVJWHA.js";
import {
  ActionsWrapper,
  awsuiPluginsInternal,
  createUseDiscoveredAction,
  createUseDiscoveredContent,
  metrics
} from "./chunk-2V4IX7V5.js";
import {
  useContainerBreakpoints
} from "./chunk-7HOTP4XT.js";
import {
  getVisualContextClassname
} from "./chunk-VITKB26C.js";
import {
  InternalButton,
  InternalSpinner,
  Transition,
  TransitionGroup_default,
  internal_default,
  internal_default2,
  useEffectOnUpdate,
  useInternalI18n
} from "./chunk-A62YXFPX.js";
import {
  DATA_ATTR_ANALYTICS_FLASHBAR,
  scrollElementIntoView
} from "./chunk-EGDAGNLX.js";
import {
  getAnalyticsMetadataAttribute
} from "./chunk-IQEN54MI.js";
import {
  isDevelopment
} from "./chunk-TIE5RIC4.js";
import {
  useMergeRefs
} from "./chunk-PSZT54K7.js";
import {
  useUniqueId
} from "./chunk-USK37E6T.js";
import {
  PACKAGE_VERSION,
  __rest,
  applyDisplayName,
  clsx_m_default,
  findUpUntil,
  getAnalyticsMetadataProps,
  getBaseProps,
  useBaseComponent,
  useComponentMetadata,
  useReducedMotion,
  useVisualRefresh,
  warnOnce
} from "./chunk-4LQYZJVR.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@cloudscape-design/components/flashbar/index.js
var import_react5 = __toESM(require_react());

// node_modules/@cloudscape-design/components/flashbar/collapsible-flashbar.js
var import_react3 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/animate.js
function getDOMRects(elements) {
  const rects = {};
  for (const id in elements) {
    const element = elements[id];
    if (element) {
      rects[id] = element.getBoundingClientRect();
    }
  }
  return rects;
}
function animate({ oldState, elements, onTransitionsEnd, newElementInitialState }) {
  for (const id in elements) {
    const element = elements[id];
    const oldRect = oldState[id];
    if (element) {
      const newRect = element.getBoundingClientRect();
      const noOpTransform = { scale: 1, x: 0, y: 0 };
      const calculatedInverseTransform = oldRect ? {
        scale: oldRect.width / newRect.width,
        x: (oldRect.left + oldRect.right) / 2 - (newRect.left + newRect.right) / 2,
        y: (oldRect.top + oldRect.bottom) / 2 - (newRect.top + newRect.bottom) / 2
      } : newElementInitialState ? newElementInitialState(newRect) : {};
      const inverseTransform = Object.assign(Object.assign({}, noOpTransform), calculatedInverseTransform);
      element.style.transitionProperty = "none";
      element.style.transform = `scale(${inverseTransform.scale}) translate(${inverseTransform.x}px, ${inverseTransform.y}px)`;
      if (!oldRect) {
        element.style.opacity = "0";
      }
    }
  }
  requestAnimationFrame(() => {
    const ongoingAnimations = /* @__PURE__ */ new Set();
    for (const id in elements) {
      const element = elements[id];
      if (element) {
        const oldRect = oldState[id];
        if (oldRect) {
          element.style.transitionProperty = `transform`;
          element.style.transform = "";
        } else {
          element.style.transitionProperty = `transform, opacity`;
          element.style.transform = "";
          element.style.opacity = "";
        }
        const onTransitionStart = (event) => {
          if (event.target === element) {
            ongoingAnimations.add(id);
            element.removeEventListener("transitionstart", onTransitionStart);
          }
        };
        const onTransitionEnd = (event) => {
          if (event.target === element) {
            element.style.transitionProperty = "";
            element.removeEventListener("transitionend", onTransitionEnd);
            if (onTransitionsEnd) {
              ongoingAnimations.delete(id);
              if (ongoingAnimations.size === 0) {
                onTransitionsEnd();
              }
            }
          }
        };
        element.addEventListener("transitionstart", onTransitionStart);
        element.addEventListener("transitionend", onTransitionEnd);
      }
    }
  });
}

// node_modules/@cloudscape-design/components/flashbar/analytics-metadata/styles.css.js
import "/home/a171157/personal-repos/deep-racer/community-contributions/deepracer-custom-console/new/node_modules/@cloudscape-design/components/flashbar/analytics-metadata/styles.scoped.css";
var styles_css_default = {
  "flash-header": "awsui_flash-header_4c95g_vov7p_5"
};

// node_modules/@cloudscape-design/components/flashbar/analytics-metadata/utils.js
var getComponentsAnalyticsMetadata = (itemsCount, stackItems, expanded) => {
  const metadata = {
    component: {
      name: "awsui.Flashbar",
      label: stackItems ? { root: "self", selector: "ul" } : { root: "self" },
      properties: {
        itemsCount: `${itemsCount}`,
        stackItems: `${stackItems}`
      }
    }
  };
  if (expanded !== void 0) {
    metadata.component.properties.expanded = `${expanded}`;
  }
  return metadata;
};
var getItemAnalyticsMetadata = (position, type, id) => {
  const baseMetadata = {
    itemLabel: `.${styles_css_default["flash-header"]}`,
    itemPosition: `${position}`,
    itemType: type
  };
  if (id) {
    baseMetadata.itemId = id;
  }
  return {
    component: { innerContext: baseMetadata }
  };
};

// node_modules/@cloudscape-design/components/flashbar/common.js
var import_react2 = __toESM(require_react());

// node_modules/@cloudscape-design/components/flashbar/flash.js
var import_react = __toESM(require_react());

// node_modules/@cloudscape-design/components/flashbar/utils.js
var FOCUS_THROTTLE_DELAY = 2e3;
var typesToColors = {
  error: "red",
  info: "blue",
  "in-progress": "blue",
  success: "green",
  warning: "yellow"
};
function getColorFromType(type) {
  const defaultColor = "blue";
  return type ? typesToColors[type] || defaultColor : defaultColor;
}
function getItemType(item) {
  if (item.loading) {
    return "in-progress";
  } else {
    return item.type || "info";
  }
}
function getItemColor(item) {
  return getColorFromType(getItemType(item));
}
function getVisibleCollapsedItems(items, desiredLength) {
  const itemsOnTop = [];
  const itemsToPromote = [];
  const addedColors = /* @__PURE__ */ new Set();
  const allPossibleColors = Object.keys(typesToColors).length;
  const finalLength = Math.min(items.length, desiredLength);
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    const color = getItemColor(item);
    const isColorRepeated = addedColors.has(color);
    if (i < finalLength) {
      itemsOnTop.push({ item: Object.assign(Object.assign({}, item), { expandedIndex: i }), isColorRepeated });
    } else {
      if (addedColors.size === allPossibleColors) {
        break;
      } else if (!isColorRepeated) {
        itemsToPromote.push(Object.assign(Object.assign({}, item), { expandedIndex: i }));
      }
    }
    addedColors.add(color);
  }
  const reversedInitialSelection = [];
  let slotsReservedForPromotions = 0;
  for (let j = itemsOnTop.length - 1; j >= 0; j--) {
    const item = itemsOnTop[j];
    if (item.isColorRepeated && slotsReservedForPromotions < itemsToPromote.length) {
      slotsReservedForPromotions += 1;
    } else {
      reversedInitialSelection.push(item.item);
    }
  }
  const selectedItems = reversedInitialSelection.reverse();
  for (let k = 0; selectedItems.length < desiredLength; k++) {
    selectedItems.push(itemsToPromote[k]);
  }
  return selectedItems;
}
function getFlashTypeCount(items) {
  const count = { error: 0, info: 0, "in-progress": 0, success: 0, warning: 0 };
  for (const item of items) {
    const type = getItemType(item);
    count[type] += 1;
  }
  return count;
}
var counterTypes = [
  { type: "error", labelName: "errorIconAriaLabel", iconName: "status-negative" },
  { type: "warning", labelName: "warningIconAriaLabel", iconName: "status-warning" },
  { type: "success", labelName: "successIconAriaLabel", iconName: "status-positive" },
  { type: "info", labelName: "infoIconAriaLabel", iconName: "status-info" },
  { type: "in-progress", labelName: "inProgressIconAriaLabel", iconName: "status-in-progress" }
];

// node_modules/@cloudscape-design/components/flashbar/internal/analytics.js
var eventContext = "csa_flashbar";
var sendRenderMetric = (items) => {
  const countByType = getFlashTypeCount(items);
  metrics.sendPanoramaMetric({
    eventContext,
    eventType: "render",
    eventValue: items.length.toString(),
    eventDetail: countByType
  });
};
var sendToggleMetric = (itemsCount, expanded) => {
  metrics.sendPanoramaMetric({
    eventContext,
    eventType: expanded ? "expand" : "collapse",
    eventValue: itemsCount.toString()
  });
};
var sendDismissMetric = (itemType) => {
  metrics.sendPanoramaMetric({
    eventContext,
    eventType: "dismiss",
    eventValue: itemType
  });
};

// node_modules/@cloudscape-design/components/flashbar/styles.css.js
import "/home/a171157/personal-repos/deep-racer/community-contributions/deepracer-custom-console/new/node_modules/@cloudscape-design/components/flashbar/styles.scoped.css";
var styles_css_default2 = {
  "flash-with-motion": "awsui_flash-with-motion_1q84n_ld8k0_157",
  "enter": "awsui_enter_1q84n_ld8k0_157",
  "flash-body": "awsui_flash-body_1q84n_ld8k0_171",
  "flash-message": "awsui_flash-message_1q84n_ld8k0_171",
  "flash-header": "awsui_flash-header_1q84n_ld8k0_171",
  "flash-content": "awsui_flash-content_1q84n_ld8k0_172",
  "action-button-wrapper": "awsui_action-button-wrapper_1q84n_ld8k0_173",
  "dismiss-button-wrapper": "awsui_dismiss-button-wrapper_1q84n_ld8k0_174",
  "flash-icon": "awsui_flash-icon_1q84n_ld8k0_197",
  "entering": "awsui_entering_1q84n_ld8k0_210",
  "entered": "awsui_entered_1q84n_ld8k0_231",
  "exiting": "awsui_exiting_1q84n_ld8k0_336",
  "stack": "awsui_stack_1q84n_ld8k0_370",
  "animation-running": "awsui_animation-running_1q84n_ld8k0_370",
  "item": "awsui_item_1q84n_ld8k0_370",
  "flash-list-item": "awsui_flash-list-item_1q84n_ld8k0_371",
  "notification-bar": "awsui_notification-bar_1q84n_ld8k0_372",
  "collapsed": "awsui_collapsed_1q84n_ld8k0_392",
  "animation-ready": "awsui_animation-ready_1q84n_ld8k0_392",
  "expanded-only": "awsui_expanded-only_1q84n_ld8k0_392",
  "expanded": "awsui_expanded_1q84n_ld8k0_392",
  "flash": "awsui_flash_1q84n_ld8k0_157",
  "collapsible": "awsui_collapsible_1q84n_ld8k0_448",
  "short-list": "awsui_short-list_1q84n_ld8k0_454",
  "visual-refresh": "awsui_visual-refresh_1q84n_ld8k0_454",
  "status": "awsui_status_1q84n_ld8k0_601",
  "header": "awsui_header_1q84n_ld8k0_601",
  "item-count": "awsui_item-count_1q84n_ld8k0_602",
  "button": "awsui_button_1q84n_ld8k0_603",
  "type-count": "awsui_type-count_1q84n_ld8k0_636",
  "count-number": "awsui_count-number_1q84n_ld8k0_636",
  "icon": "awsui_icon_1q84n_ld8k0_670",
  "floating": "awsui_floating_1q84n_ld8k0_711",
  "flashbar": "awsui_flashbar_1q84n_ld8k0_715",
  "initial-hidden": "awsui_initial-hidden_1q84n_ld8k0_773",
  "flash-list": "awsui_flash-list_1q84n_ld8k0_371",
  "flash-focus-container": "awsui_flash-focus-container_1q84n_ld8k0_795",
  "flash-text": "awsui_flash-text_1q84n_ld8k0_825",
  "hidden": "awsui_hidden_1q84n_ld8k0_844",
  "header-replacement": "awsui_header-replacement_1q84n_ld8k0_849",
  "content-replacement": "awsui_content-replacement_1q84n_ld8k0_854",
  "dismiss-button": "awsui_dismiss-button_1q84n_ld8k0_174",
  "breakpoint-default": "awsui_breakpoint-default_1q84n_ld8k0_873",
  "action-button": "awsui_action-button_1q84n_ld8k0_173",
  "action-slot": "awsui_action-slot_1q84n_ld8k0_883",
  "flash-type-success": "awsui_flash-type-success_1q84n_ld8k0_887",
  "flash-type-error": "awsui_flash-type-error_1q84n_ld8k0_891",
  "flash-type-info": "awsui_flash-type-info_1q84n_ld8k0_895",
  "flash-type-in-progress": "awsui_flash-type-in-progress_1q84n_ld8k0_896",
  "flash-type-warning": "awsui_flash-type-warning_1q84n_ld8k0_900"
};

// node_modules/@cloudscape-design/components/flashbar/flash.js
var ICON_TYPES = {
  success: "status-positive",
  warning: "status-warning",
  info: "status-info",
  error: "status-negative",
  "in-progress": "status-in-progress"
};
var useDiscoveredAction = createUseDiscoveredAction(awsuiPluginsInternal.flashbar.onActionRegistered);
var useDiscoveredContent = createUseDiscoveredContent("flash", awsuiPluginsInternal.flashContent);
function dismissButton(dismissLabel, onDismiss) {
  return import_react.default.createElement(
    "div",
    Object.assign({ className: styles_css_default2["dismiss-button-wrapper"] }, getAnalyticsMetadataAttribute({
      action: "dismiss"
    })),
    import_react.default.createElement(InternalButton, { onClick: onDismiss, className: styles_css_default2["dismiss-button"], variant: "flashbar-icon", iconName: "close", formAction: "none", ariaLabel: dismissLabel })
  );
}
var focusFlashById = throttle((element, itemId) => {
  var _a;
  const selector = `[data-itemid="${CSS.escape(itemId)}"] .${styles_css_default2["flash-focus-container"]}`;
  (_a = element === null || element === void 0 ? void 0 : element.querySelector(selector)) === null || _a === void 0 ? void 0 : _a.focus();
}, FOCUS_THROTTLE_DELAY, { trailing: false });
var Flash = import_react.default.forwardRef((_a, ref) => {
  var { id, header, content, dismissible, dismissLabel, loading, action, buttonText, onButtonClick, onDismiss, className, transitionState, ariaRole, i18nStrings, type = "info" } = _a, props = __rest(_a, ["id", "header", "content", "dismissible", "dismissLabel", "loading", "action", "buttonText", "onButtonClick", "onDismiss", "className", "transitionState", "ariaRole", "i18nStrings", "type"]);
  if (isDevelopment) {
    if (buttonText && !onButtonClick) {
      warnOnce("Flashbar", `You provided a \`buttonText\` prop without an \`onButtonClick\` handler. This will render a non-interactive action button.`);
    }
    if (dismissible && !onDismiss) {
      warnOnce("Flashbar", `You have set the \`dismissible\` prop without an \`onDismiss\` handler. This will render a non-interactive dismiss button.`);
    }
  }
  const analyticsMetadata = getAnalyticsMetadataProps(props);
  const elementRef = useComponentMetadata("Flash", PACKAGE_VERSION, Object.assign({}, analyticsMetadata));
  const mergedRef = useMergeRefs(ref, elementRef);
  const headerRefObject = (0, import_react.useRef)(null);
  const contentRefObject = (0, import_react.useRef)(null);
  const { discoveredActions, headerRef: headerRefAction, contentRef: contentRefAction } = useDiscoveredAction(type);
  const { initialHidden, headerReplacementType, contentReplacementType, headerRef: headerRefContent, contentRef: contentRefContent, replacementHeaderRef, replacementContentRef } = useDiscoveredContent({ type, header, children: content });
  const headerRef = useMergeRefs(headerRefAction, headerRefContent, headerRefObject);
  const contentRef = useMergeRefs(contentRefAction, contentRefContent, contentRefObject);
  const iconType = ICON_TYPES[type];
  const icon = loading ? import_react.default.createElement(InternalSpinner, null) : import_react.default.createElement(internal_default, { name: iconType });
  const effectiveType = loading ? "info" : type;
  const handleDismiss = (event) => {
    sendDismissMetric(effectiveType);
    onDismiss && onDismiss(event);
  };
  const analyticsAttributes = {
    [DATA_ATTR_ANALYTICS_FLASHBAR]: effectiveType
  };
  const statusIconAriaLabel = props.statusIconAriaLabel || (i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings[`${loading || type === "in-progress" ? "inProgress" : type}IconAriaLabel`]);
  return (
    // We're not using "polite" or "assertive" here, just turning default behavior off.
    // eslint-disable-next-line @cloudscape-design/prefer-live-region
    import_react.default.createElement(
      "div",
      Object.assign({ ref: mergedRef, role: ariaRole, "aria-live": ariaRole ? "off" : void 0, "data-itemid": id, className: clsx_m_default(styles_css_default2.flash, styles_css_default2[`flash-type-${effectiveType}`], className, transitionState && {
        [styles_css_default2.enter]: transitionState === "enter",
        [styles_css_default2.entering]: transitionState === "entering",
        [styles_css_default2.entered]: transitionState === "entered",
        [styles_css_default2.exit]: transitionState === "exit",
        [styles_css_default2.exiting]: transitionState === "exiting",
        [styles_css_default2.exited]: transitionState === "exited"
      }, getVisualContextClassname(type === "warning" && !loading ? "flashbar-warning" : "flashbar"), initialHidden && styles_css_default2["initial-hidden"]) }, analyticsAttributes),
      import_react.default.createElement(
        "div",
        { className: styles_css_default2["flash-body"] },
        import_react.default.createElement(
          "div",
          { className: styles_css_default2["flash-focus-container"], tabIndex: -1 },
          import_react.default.createElement("div", { className: clsx_m_default(styles_css_default2["flash-icon"], styles_css_default2["flash-text"]), role: "img", "aria-label": statusIconAriaLabel }, icon),
          import_react.default.createElement(
            "div",
            { className: clsx_m_default(styles_css_default2["flash-message"], styles_css_default2["flash-text"]) },
            import_react.default.createElement("div", { className: clsx_m_default(styles_css_default2["flash-header"], headerReplacementType !== "original" ? styles_css_default2.hidden : styles_css_default["flash-header"]), ref: headerRef }, header),
            import_react.default.createElement("div", { className: clsx_m_default(styles_css_default2["header-replacement"], headerReplacementType !== "replaced" && styles_css_default2.hidden), ref: replacementHeaderRef }),
            import_react.default.createElement("div", { className: clsx_m_default(styles_css_default2["flash-content"], contentReplacementType !== "original" ? styles_css_default2.hidden : styles_css_default["flash-header"]), ref: contentRef }, content),
            import_react.default.createElement("div", { className: clsx_m_default(styles_css_default2["content-replacement"], contentReplacementType !== "replaced" && styles_css_default2.hidden), ref: replacementContentRef })
          )
        ),
        import_react.default.createElement(ActionsWrapper, { className: styles_css_default2["action-button-wrapper"], testUtilClasses: {
          actionSlot: styles_css_default2["action-slot"],
          actionButton: styles_css_default2["action-button"]
        }, action, discoveredActions, buttonText, onButtonClick })
      ),
      dismissible && dismissButton(dismissLabel, handleDismiss),
      ariaRole === "status" && import_react.default.createElement(internal_default2, { sources: [statusIconAriaLabel, headerRefObject, contentRefObject] })
    )
  );
});

// node_modules/@cloudscape-design/components/flashbar/common.js
function useFlashbar(_a) {
  var { items, onItemsAdded, onItemsChanged, onItemsRemoved } = _a, restProps = __rest(_a, ["items", "onItemsAdded", "onItemsChanged", "onItemsRemoved"]);
  const { __internalRootRef } = useBaseComponent("Flashbar", {
    props: { stackItems: restProps.stackItems }
  });
  const allItemsHaveId = (0, import_react2.useMemo)(() => items.every((item) => "id" in item), [items]);
  const baseProps = getBaseProps(restProps);
  const ref = (0, import_react2.useRef)(null);
  const [breakpoint, breakpointRef] = useContainerBreakpoints(["xs"]);
  const mergedRef = useMergeRefs(ref, breakpointRef, __internalRootRef);
  const isReducedMotion = useReducedMotion(ref);
  const isVisualRefresh = useVisualRefresh();
  const [previousItems, setPreviousItems] = (0, import_react2.useState)(items);
  const [nextFocusId, setNextFocusId] = (0, import_react2.useState)(null);
  if (isDevelopment) {
    if (items === null || items === void 0 ? void 0 : items.some((item) => item.ariaRole === "alert" && !item.id)) {
      warnOnce("Flashbar", `You provided \`ariaRole="alert"\` for a flashbar item without providing an \`id\`. Focus will not be moved to the newly added flash message.`);
    }
  }
  if (items) {
    const newItems = items.filter(({ id }) => id && !previousItems.some((item) => item.id === id));
    const removedItems = previousItems.filter(({ id }) => id && !items.some((item) => item.id === id));
    if (newItems.length > 0 || removedItems.length > 0) {
      setPreviousItems(items);
      onItemsAdded === null || onItemsAdded === void 0 ? void 0 : onItemsAdded(newItems);
      onItemsRemoved === null || onItemsRemoved === void 0 ? void 0 : onItemsRemoved(removedItems);
      onItemsChanged === null || onItemsChanged === void 0 ? void 0 : onItemsChanged({ allItemsHaveId, isReducedMotion });
      const newFocusItems = newItems.filter(({ ariaRole }) => ariaRole === "alert");
      if (newFocusItems.length > 0) {
        setNextFocusId(newFocusItems[0].id);
      }
    }
  }
  (0, import_react2.useEffect)(() => {
    if (nextFocusId) {
      focusFlashById(ref.current, nextFocusId);
    }
  }, [nextFocusId, ref]);
  return {
    allItemsHaveId,
    baseProps,
    breakpoint,
    isReducedMotion,
    isVisualRefresh,
    mergedRef,
    ref
  };
}

// node_modules/@cloudscape-design/components/flashbar/collapsible-flashbar.js
var maxNonCollapsibleItems = 1;
var resizeListenerThrottleDelay = 100;
function CollapsibleFlashbar(_a) {
  var { items } = _a, restProps = __rest(_a, ["items"]);
  const [enteringItems, setEnteringItems] = (0, import_react3.useState)([]);
  const [exitingItems, setExitingItems] = (0, import_react3.useState)([]);
  const [isFlashbarStackExpanded, setIsFlashbarStackExpanded] = (0, import_react3.useState)(false);
  const getElementsToAnimate = (0, import_react3.useCallback)(() => {
    const flashElements = isFlashbarStackExpanded ? expandedItemRefs.current : collapsedItemRefs.current;
    return Object.assign(Object.assign({}, flashElements), { notificationBar: notificationBarRef.current });
  }, [isFlashbarStackExpanded]);
  const prepareAnimations = (0, import_react3.useCallback)(() => {
    const rects = getDOMRects(getElementsToAnimate());
    setInitialAnimationState(rects);
  }, [getElementsToAnimate]);
  const { baseProps, breakpoint, isReducedMotion, isVisualRefresh, mergedRef, ref } = useFlashbar(Object.assign(Object.assign({ items }, restProps), { onItemsAdded: (newItems) => {
    setEnteringItems([...enteringItems, ...newItems]);
  }, onItemsChanged: (options) => {
    if ((options === null || options === void 0 ? void 0 : options.allItemsHaveId) && !(options === null || options === void 0 ? void 0 : options.isReducedMotion)) {
      prepareAnimations();
    }
  }, onItemsRemoved: (removedItems) => {
    setExitingItems([...exitingItems, ...removedItems]);
  } }));
  const collapsedItemRefs = (0, import_react3.useRef)({});
  const expandedItemRefs = (0, import_react3.useRef)({});
  const [initialAnimationState, setInitialAnimationState] = (0, import_react3.useState)(null);
  const listElementRef = (0, import_react3.useRef)(null);
  const notificationBarRef = (0, import_react3.useRef)(null);
  const [transitioning, setTransitioning] = (0, import_react3.useState)(false);
  const flashbarElementId = useUniqueId("flashbar");
  const itemCountElementId = useUniqueId("item-count");
  if (items.length <= maxNonCollapsibleItems && isFlashbarStackExpanded) {
    setIsFlashbarStackExpanded(false);
  }
  const animateFlash = !isReducedMotion;
  function toggleCollapseExpand() {
    sendToggleMetric(items.length, !isFlashbarStackExpanded);
    if (!isReducedMotion) {
      prepareAnimations();
    }
    setIsFlashbarStackExpanded((prev) => !prev);
  }
  (0, import_react3.useLayoutEffect)(() => {
    if (isFlashbarStackExpanded && (items === null || items === void 0 ? void 0 : items.length)) {
      const mostRecentItem = items[0];
      if (mostRecentItem.id !== void 0) {
        focusFlashById(ref.current, mostRecentItem.id);
      }
    }
  }, [isFlashbarStackExpanded]);
  useEffectOnUpdate(() => {
    if (!isFlashbarStackExpanded && notificationBarRef.current) {
      scrollElementIntoView(notificationBarRef.current);
    }
  }, [isFlashbarStackExpanded]);
  const updateBottomSpacing = (0, import_react3.useMemo)(() => throttle(() => {
    const listElement = listElementRef === null || listElementRef === void 0 ? void 0 : listElementRef.current;
    const flashbar = listElement === null || listElement === void 0 ? void 0 : listElement.parentElement;
    if (listElement && flashbar) {
      flashbar.classList.remove(styles_css_default2.floating);
      const windowHeight = window.innerHeight;
      const outerElement = findUpUntil(flashbar, (element) => element.getAttribute("role") === "region") || flashbar;
      const applySpacing = isFlashbarStackExpanded && Math.ceil(outerElement.getBoundingClientRect().bottom) >= windowHeight;
      if (!applySpacing) {
        flashbar.classList.add(styles_css_default2.floating);
      }
    }
  }, resizeListenerThrottleDelay), [isFlashbarStackExpanded]);
  (0, import_react3.useLayoutEffect)(() => {
    window.addEventListener("resize", updateBottomSpacing);
    return () => {
      window.removeEventListener("resize", updateBottomSpacing);
      updateBottomSpacing.cancel();
    };
  }, [updateBottomSpacing]);
  const { i18nStrings } = restProps;
  const i18n = useInternalI18n("flashbar");
  const ariaLabel = i18n("i18nStrings.ariaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.ariaLabel);
  const notificationBarText = i18n("i18nStrings.notificationBarText", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.notificationBarText);
  const notificationBarAriaLabel = i18n("i18nStrings.notificationBarAriaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.notificationBarAriaLabel);
  const iconAriaLabels = {
    errorIconAriaLabel: i18n("i18nStrings.errorIconAriaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.errorIconAriaLabel),
    inProgressIconAriaLabel: i18n("i18nStrings.inProgressIconAriaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.inProgressIconAriaLabel),
    infoIconAriaLabel: i18n("i18nStrings.infoIconAriaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.infoIconAriaLabel),
    successIconAriaLabel: i18n("i18nStrings.successIconAriaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.successIconAriaLabel),
    warningIconAriaLabel: i18n("i18nStrings.warningIconAriaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.warningIconAriaLabel)
  };
  (0, import_react3.useLayoutEffect)(() => {
    if (initialAnimationState) {
      updateBottomSpacing();
      animate({
        elements: getElementsToAnimate(),
        oldState: initialAnimationState,
        newElementInitialState: ({ top }) => ({ scale: 0.9, y: -0.2 * top }),
        onTransitionsEnd: () => setTransitioning(false)
      });
      setTransitioning(true);
      setInitialAnimationState(null);
    }
  }, [updateBottomSpacing, getElementsToAnimate, initialAnimationState, isFlashbarStackExpanded]);
  const isCollapsible = items.length > maxNonCollapsibleItems;
  const countByType = getFlashTypeCount(items);
  const numberOfColorsInStack = new Set(items.map(getItemColor)).size;
  const maxSlots = Math.max(numberOfColorsInStack, 3);
  const stackDepth = Math.min(maxSlots, items.length);
  const itemsToShow = isFlashbarStackExpanded ? items.map((item, index) => Object.assign(Object.assign({}, item), { expandedIndex: index })) : getVisibleCollapsedItems(items, stackDepth).map((item, index) => Object.assign(Object.assign({}, item), { collapsedIndex: index }));
  const getItemId = (item) => {
    var _a2, _b;
    return (_b = (_a2 = item.id) !== null && _a2 !== void 0 ? _a2 : item.expandedIndex) !== null && _b !== void 0 ? _b : 0;
  };
  const hasEntered = (item) => enteringItems.some((_item) => _item.id && _item.id === item.id);
  const hasLeft = (item) => !("expandedIndex" in item);
  const hasEnteredOrLeft = (item) => hasEntered(item) || hasLeft(item);
  const showInnerContent = (item) => isFlashbarStackExpanded || hasLeft(item) || "expandedIndex" in item && item.expandedIndex === 0;
  const shouldUseStandardAnimation = (item, index) => index === 0 && hasEnteredOrLeft(item);
  const getAnimationElementId = (item) => `flash-${getItemId(item)}`;
  const renderList = () => import_react3.default.createElement(
    "ul",
    { ref: listElementRef, className: clsx_m_default(styles_css_default2["flash-list"], isFlashbarStackExpanded ? styles_css_default2.expanded : styles_css_default2.collapsed, transitioning && styles_css_default2["animation-running"], initialAnimationState && styles_css_default2["animation-ready"], isVisualRefresh && styles_css_default2["visual-refresh"]), id: flashbarElementId, "aria-label": ariaLabel, "aria-describedby": isCollapsible ? itemCountElementId : void 0, style: !isFlashbarStackExpanded || transitioning ? {
      [custom_css_properties_default.flashbarStackDepth]: stackDepth
    } : void 0 },
    import_react3.default.createElement(ListWrapper, { withMotion: !isReducedMotion }, itemsToShow.map((item, index) => import_react3.default.createElement(Transition, { key: getItemId(item), in: !hasLeft(item), onStatusChange: (status) => {
      if (status === "entered") {
        setEnteringItems([]);
      } else if (status === "exited") {
        setExitingItems([]);
      }
    } }, (state, transitionRootElement) => {
      var _a2, _b, _c;
      return import_react3.default.createElement("li", Object.assign({ "aria-hidden": !showInnerContent(item), className: showInnerContent(item) ? clsx_m_default(styles_css_default2["flash-list-item"], !isFlashbarStackExpanded && styles_css_default2.item, !collapsedItemRefs.current[getAnimationElementId(item)] && styles_css_default2["expanded-only"]) : clsx_m_default(styles_css_default2.flash, styles_css_default2[`flash-type-${(_a2 = item.type) !== null && _a2 !== void 0 ? _a2 : "info"}`], styles_css_default2.item), ref: (element) => {
        if (isFlashbarStackExpanded) {
          expandedItemRefs.current[getAnimationElementId(item)] = element;
        } else {
          collapsedItemRefs.current[getAnimationElementId(item)] = element;
        }
      }, style: !isFlashbarStackExpanded || transitioning ? {
        [custom_css_properties_default.flashbarStackIndex]: (_c = (_b = item.collapsedIndex) !== null && _b !== void 0 ? _b : item.expandedIndex) !== null && _c !== void 0 ? _c : index
      } : void 0, key: getItemId(item) }, getAnalyticsMetadataAttribute(getItemAnalyticsMetadata(index + 1, item.type || "info", item.id))), showInnerContent(item) && import_react3.default.createElement(
        Flash,
        Object.assign({
          // eslint-disable-next-line react/forbid-component-props
          className: clsx_m_default(animateFlash && styles_css_default2["flash-with-motion"], isVisualRefresh && styles_css_default2["flash-refresh"]),
          key: getItemId(item),
          ref: shouldUseStandardAnimation(item, index) ? transitionRootElement : void 0,
          transitionState: shouldUseStandardAnimation(item, index) ? state : void 0,
          i18nStrings: iconAriaLabels
        }, item)
      ));
    })))
  );
  return import_react3.default.createElement(
    "div",
    Object.assign({}, baseProps, { className: clsx_m_default(baseProps.className, styles_css_default2.flashbar, styles_css_default2[`breakpoint-${breakpoint}`], styles_css_default2.stack, isCollapsible && styles_css_default2.collapsible, items.length === 2 && styles_css_default2["short-list"], isFlashbarStackExpanded && styles_css_default2.expanded, isVisualRefresh && styles_css_default2["visual-refresh"]), ref: mergedRef }, getAnalyticsMetadataAttribute(getComponentsAnalyticsMetadata(items.length, true, isFlashbarStackExpanded))),
    isFlashbarStackExpanded && renderList(),
    isCollapsible && import_react3.default.createElement(
      "div",
      Object.assign({ className: clsx_m_default(
        styles_css_default2["notification-bar"],
        isVisualRefresh && styles_css_default2["visual-refresh"],
        isFlashbarStackExpanded ? styles_css_default2.expanded : styles_css_default2.collapsed,
        transitioning && styles_css_default2["animation-running"],
        items.length === 2 && styles_css_default2["short-list"],
        getVisualContextClassname("flashbar")
        // Visual context is needed for focus ring to be white
      ), onClick: toggleCollapseExpand, ref: notificationBarRef }, getAnalyticsMetadataAttribute({
        action: "expand",
        detail: {
          label: "h2",
          expanded: `${!isFlashbarStackExpanded}`
        }
      })),
      import_react3.default.createElement(
        "span",
        { "aria-live": "polite", className: styles_css_default2.status, role: "status", id: itemCountElementId },
        notificationBarText && import_react3.default.createElement("h2", { className: styles_css_default2.header }, notificationBarText),
        import_react3.default.createElement("span", { className: styles_css_default2["item-count"] }, counterTypes.map(({ type, labelName, iconName }) => import_react3.default.createElement(NotificationTypeCount, { key: type, iconName, label: iconAriaLabels[labelName], count: countByType[type] })))
      ),
      import_react3.default.createElement(
        "button",
        { "aria-controls": flashbarElementId, "aria-describedby": itemCountElementId, "aria-expanded": isFlashbarStackExpanded, "aria-label": notificationBarAriaLabel, className: clsx_m_default(styles_css_default2.button, isFlashbarStackExpanded && styles_css_default2.expanded) },
        import_react3.default.createElement(internal_default, { className: styles_css_default2.icon, size: "normal", name: "angle-down" })
      )
    ),
    !isFlashbarStackExpanded && renderList()
  );
}
var NotificationTypeCount = ({ iconName, label, count }) => {
  return import_react3.default.createElement(
    "span",
    { className: styles_css_default2["type-count"] },
    import_react3.default.createElement(
      "span",
      { "aria-label": label, role: "img" },
      import_react3.default.createElement(
        "span",
        { title: label, "aria-hidden": "true" },
        import_react3.default.createElement(internal_default, { name: iconName })
      )
    ),
    import_react3.default.createElement("span", { className: styles_css_default2["count-number"] }, count)
  );
};
var ListWrapper = ({ children, withMotion }) => withMotion ? import_react3.default.createElement(TransitionGroup_default, { component: null }, children) : import_react3.default.createElement(import_react3.default.Fragment, null, children);

// node_modules/@cloudscape-design/components/flashbar/non-collapsible-flashbar.js
var import_react4 = __toESM(require_react());

// node_modules/@cloudscape-design/components/flashbar/constant.js
var TIMEOUT_FOR_ENTERING_ANIMATION = 115;

// node_modules/@cloudscape-design/components/flashbar/non-collapsible-flashbar.js
function NonCollapsibleFlashbar(_a) {
  var { items, i18nStrings } = _a, restProps = __rest(_a, ["items", "i18nStrings"]);
  const { allItemsHaveId, baseProps, breakpoint, isReducedMotion, isVisualRefresh, mergedRef } = useFlashbar(Object.assign({ items }, restProps));
  const i18n = useInternalI18n("flashbar");
  const ariaLabel = i18n("i18nStrings.ariaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.ariaLabel);
  const iconAriaLabels = {
    errorIconAriaLabel: i18n("i18nStrings.errorIconAriaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.errorIconAriaLabel),
    inProgressIconAriaLabel: i18n("i18nStrings.inProgressIconAriaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.inProgressIconAriaLabel),
    infoIconAriaLabel: i18n("i18nStrings.infoIconAriaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.infoIconAriaLabel),
    successIconAriaLabel: i18n("i18nStrings.successIconAriaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.successIconAriaLabel),
    warningIconAriaLabel: i18n("i18nStrings.warningIconAriaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.warningIconAriaLabel)
  };
  const motionDisabled = isReducedMotion || !isVisualRefresh || !allItemsHaveId;
  const animateFlash = !isReducedMotion && isVisualRefresh;
  function renderFlatItemsWithTransitions() {
    if (motionDisabled || !items) {
      return;
    }
    return (
      // This is a proxy for <ul>, so we're not applying a class to another actual component.
      // eslint-disable-next-line react/forbid-component-props
      import_react4.default.createElement(TransitionGroup_default, { component: "ul", className: styles_css_default2["flash-list"], "aria-label": ariaLabel }, items.map((item, index) => {
        var _a2;
        return import_react4.default.createElement(Transition, { transitionChangeDelay: { entering: TIMEOUT_FOR_ENTERING_ANIMATION }, key: (_a2 = item.id) !== null && _a2 !== void 0 ? _a2 : index, in: true }, (state, transitionRootElement) => {
          var _a3;
          return import_react4.default.createElement("li", { className: styles_css_default2["flash-list-item"] }, renderItem(item, (_a3 = item.id) !== null && _a3 !== void 0 ? _a3 : index, transitionRootElement, state));
        });
      }))
    );
  }
  function renderFlatItemsWithoutTransitions() {
    if (!motionDisabled || !items) {
      return;
    }
    return import_react4.default.createElement("ul", Object.assign({ className: styles_css_default2["flash-list"], "aria-label": ariaLabel }, getAnalyticsMetadataAttribute(getComponentsAnalyticsMetadata(items.length, false))), items.map((item, index) => {
      var _a2, _b;
      return import_react4.default.createElement("li", Object.assign({ key: (_a2 = item.id) !== null && _a2 !== void 0 ? _a2 : index, className: styles_css_default2["flash-list-item"] }, getAnalyticsMetadataAttribute(getItemAnalyticsMetadata(index + 1, item.type || "info", item.id))), renderItem(item, (_b = item.id) !== null && _b !== void 0 ? _b : index));
    }));
  }
  function renderItem(item, key, transitionRootElement, transitionState) {
    return import_react4.default.createElement(
      Flash,
      Object.assign({
        // eslint-disable-next-line react/forbid-component-props
        className: clsx_m_default(animateFlash && styles_css_default2["flash-with-motion"], isVisualRefresh && styles_css_default2["flash-refresh"]),
        key,
        ref: transitionRootElement,
        transitionState,
        i18nStrings: iconAriaLabels
      }, item)
    );
  }
  return import_react4.default.createElement(
    "div",
    Object.assign({}, baseProps, { className: clsx_m_default(baseProps.className, styles_css_default2.flashbar, styles_css_default2[`breakpoint-${breakpoint}`]), ref: mergedRef }),
    renderFlatItemsWithTransitions(),
    renderFlatItemsWithoutTransitions()
  );
}

// node_modules/@cloudscape-design/components/flashbar/index.js
function Flashbar(props) {
  (0, import_react5.useEffect)(() => {
    if (props.items.length > 0) {
      sendRenderMetric(props.items);
    }
  }, [props.items]);
  if (props.stackItems) {
    return import_react5.default.createElement(CollapsibleFlashbar, Object.assign({}, props));
  } else {
    return import_react5.default.createElement(NonCollapsibleFlashbar, Object.assign({}, props));
  }
}
applyDisplayName(Flashbar, "Flashbar");

export {
  Flashbar
};
//# sourceMappingURL=chunk-N5KISRUN.js.map
