{
  "version": 3,
  "sources": ["../../src/internal/context/single-tab-stop-navigation-context.tsx"],
  "sourcesContent": ["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, {\n  createContext,\n  forwardRef,\n  useContext,\n  useImperativeHandle,\n  useLayoutEffect,\n  useRef,\n  useState,\n} from 'react';\n\nimport { nodeBelongs } from '../utils/node-belongs';\n\nexport type FocusableChangeHandler = (isFocusable: boolean) => void;\n\nexport const defaultValue: {\n  navigationActive: boolean;\n  registerFocusable(focusable: HTMLElement, handler: FocusableChangeHandler): () => void;\n} = {\n  navigationActive: false,\n  registerFocusable: () => () => {},\n};\n\n/**\n * Single tab stop navigation context is used together with keyboard navigation that requires a single tab stop.\n * It instructs interactive elements to override tab indices for just a single one to remain user-focusable.\n */\nexport const SingleTabStopNavigationContext = createContext(defaultValue);\n\nexport function useSingleTabStopNavigation(\n  focusable: null | React.RefObject<HTMLElement>,\n  options?: { tabIndex?: number }\n) {\n  const { navigationActive: contextNavigationActive, registerFocusable } = useContext(SingleTabStopNavigationContext);\n  const [focusTargetActive, setFocusTargetActive] = useState(false);\n  const navigationDisabled = options?.tabIndex && options?.tabIndex < 0;\n  const navigationActive = contextNavigationActive && !navigationDisabled;\n\n  useLayoutEffect(() => {\n    if (navigationActive && focusable && focusable.current) {\n      const unregister = registerFocusable(focusable.current, isFocusable => setFocusTargetActive(isFocusable));\n      return () => unregister();\n    }\n  });\n\n  let tabIndex = options?.tabIndex;\n  if (navigationActive) {\n    tabIndex = !focusTargetActive ? -1 : options?.tabIndex ?? 0;\n  }\n\n  return { navigationActive, tabIndex };\n}\n\ninterface SingleTabStopNavigationProviderProps {\n  navigationActive: boolean;\n  children: React.ReactNode;\n  getNextFocusTarget: () => null | HTMLElement;\n  isElementSuppressed?(focusableElement: Element): boolean;\n  onRegisterFocusable?(focusableElement: Element): void;\n  onUnregisterActive?(focusableElement: Element): void;\n}\n\nexport interface SingleTabStopNavigationAPI {\n  updateFocusTarget(): void;\n  getFocusTarget(): null | HTMLElement;\n  isRegistered(element: Element): boolean;\n}\n\nexport const SingleTabStopNavigationProvider = forwardRef(\n  (\n    {\n      navigationActive,\n      children,\n      getNextFocusTarget,\n      isElementSuppressed,\n      onRegisterFocusable,\n      onUnregisterActive,\n    }: SingleTabStopNavigationProviderProps,\n    ref: React.Ref<SingleTabStopNavigationAPI>\n  ) => {\n    // A set of registered focusable elements that can use keyboard navigation.\n    const focusables = useRef(new Set<Element>());\n    // A map of registered focusable element handlers to update the respective tab indices.\n    const focusHandlers = useRef(new Map<Element, FocusableChangeHandler>());\n    // A map of focusable element states to avoid issuing unnecessary updates to registered elements.\n    const focusablesState = useRef(new WeakMap<Element, boolean>());\n    // A reference to the currently focused element.\n    const focusTarget = useRef<null | HTMLElement>(null);\n\n    function onUnregisterFocusable(focusableElement: Element) {\n      const isUnregisteringFocusedNode = nodeBelongs(focusableElement, document.activeElement);\n      if (isUnregisteringFocusedNode) {\n        // Wait for unmounted node to get removed from the DOM.\n        setTimeout(() => onUnregisterActive?.(focusableElement), 0);\n      }\n    }\n\n    // Register a focusable element to allow navigating into it.\n    // The focusable element tabIndex is only set to 0 if the element matches the focus target.\n    function registerFocusable(focusableElement: Element, changeHandler: FocusableChangeHandler) {\n      focusables.current.add(focusableElement);\n      focusHandlers.current.set(focusableElement, changeHandler);\n      const isFocusable = !!focusablesState.current.get(focusableElement);\n      const newIsFocusable = focusTarget.current === focusableElement || !!isElementSuppressed?.(focusableElement);\n      if (newIsFocusable !== isFocusable) {\n        focusablesState.current.set(focusableElement, newIsFocusable);\n        changeHandler(newIsFocusable);\n      }\n      onRegisterFocusable?.(focusableElement);\n      return () => unregisterFocusable(focusableElement);\n    }\n    function unregisterFocusable(focusableElement: Element) {\n      focusables.current.delete(focusableElement);\n      focusHandlers.current.delete(focusableElement);\n      onUnregisterFocusable?.(focusableElement);\n    }\n\n    // Update focus target with next single focusable element and notify all registered focusables of a change.\n    function updateFocusTarget() {\n      focusTarget.current = getNextFocusTarget();\n      for (const focusableElement of focusables.current) {\n        const isFocusable = focusablesState.current.get(focusableElement) ?? false;\n        const newIsFocusable = focusTarget.current === focusableElement || !!isElementSuppressed?.(focusableElement);\n        if (newIsFocusable !== isFocusable) {\n          focusablesState.current.set(focusableElement, newIsFocusable);\n          focusHandlers.current.get(focusableElement)!(newIsFocusable);\n        }\n      }\n    }\n\n    function getFocusTarget() {\n      return focusTarget.current;\n    }\n\n    function isRegistered(element: Element) {\n      return focusables.current.has(element);\n    }\n\n    useImperativeHandle(ref, () => ({ updateFocusTarget, getFocusTarget, isRegistered }));\n\n    return (\n      <SingleTabStopNavigationContext.Provider value={{ navigationActive, registerFocusable }}>\n        {children}\n      </SingleTabStopNavigationContext.Provider>\n    );\n  }\n);\n"],
  "mappings": "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",
  "names": ["React"]
}
