import {
  InternalContainer
} from "./chunk-5Q25HXDW.js";
import {
  useContainerQuery
} from "./chunk-2NIGQAX7.js";
import {
  InternalButton,
  KeyCode,
  SingleTabStopNavigationProvider,
  Tooltip,
  getAllFocusables,
  useHiddenDescription,
  useInternalI18n,
  useSingleTabStopNavigation
} from "./chunk-6I32C23F.js";
import {
  isHTMLElement,
  isSVGElement
} from "./chunk-IJR7PIFY.js";
import {
  isDevelopment
} from "./chunk-TIE5RIC4.js";
import {
  useMergeRefs
} from "./chunk-CQ36ZYSY.js";
import {
  getAnalyticsMetadataAttribute
} from "./chunk-KLORJ2MI.js";
import {
  useUniqueId
} from "./chunk-CIRQIDXF.js";
import {
  checkSafeUrl
} from "./chunk-JNXHVAPT.js";
import {
  fireNonCancelableEvent,
  hasModifierKeys,
  isPlainLeftClick
} from "./chunk-IGE3W7Z3.js";
import {
  __rest,
  applyDisplayName,
  clsx_m_default,
  getBaseProps,
  getIsRtl,
  getScrollInlineStart,
  isMotionDisabled,
  useBaseComponent,
  useVisualRefresh,
  warnOnce
} from "./chunk-KLAOVQJX.js";
import {
  require_react
} from "./chunk-YHPANKLD.js";
import {
  __toESM
} from "./chunk-PR4QN5HX.js";

// node_modules/@cloudscape-design/components/tabs/index.js
var import_react2 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/hooks/use-controllable/index.js
var React = __toESM(require_react());
function useControllable(controlledValue, handler, defaultValue, { componentName, changeHandler, controlledProp }) {
  const isControlled = React.useState(controlledValue !== void 0)[0];
  if (isDevelopment) {
    React.useEffect(() => {
      if (isControlled && handler === void 0) {
        warnOnce(componentName, `You provided a \`${controlledProp}\` prop without an \`${changeHandler}\` handler. This will render a non-interactive component.`);
      }
    }, [handler, isControlled, componentName, changeHandler, controlledProp]);
    React.useEffect(() => {
      const isControlledNow = controlledValue !== void 0;
      if (isControlled !== isControlledNow) {
        const initialMode = isControlled ? "controlled" : "uncontrolled";
        const modeNow = isControlledNow ? "controlled" : "uncontrolled";
        warnOnce(componentName, `A component tried to change ${initialMode} '${controlledProp}' property to be ${modeNow}. This is not supported. Properties should not switch from ${initialMode} to ${modeNow} (or vice versa). Decide between using a controlled or uncontrolled mode for the lifetime of the component. More info: https://fb.me/react-controlled-components`);
      }
    }, [isControlled, controlledProp, componentName, controlledValue]);
  }
  const [valueState, setValue] = React.useState(defaultValue);
  const [valueHasBeenSet, setValueHasBeenSet] = React.useState(false);
  const currentUncontrolledValue = valueHasBeenSet ? valueState : defaultValue;
  const setUncontrolledValue = React.useCallback((newValue) => {
    setValue(newValue);
    setValueHasBeenSet(true);
  }, [setValue, setValueHasBeenSet]);
  if (isControlled) {
    return [controlledValue, defaultCallback];
  } else {
    return [currentUncontrolledValue, setUncontrolledValue];
  }
}
function defaultCallback() {
  return void 0;
}

// node_modules/@cloudscape-design/components/tabs/tab-header-bar.js
var import_react = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/utils/circle-index.js
function circleIndex(index, [from, to]) {
  if (index < from) {
    return to;
  }
  if (index > to) {
    return from;
  }
  return index;
}

// node_modules/@cloudscape-design/components/internal/utils/handle-key.js
function isEventLike(event) {
  return isHTMLElement(event.currentTarget) || isSVGElement(event.currentTarget);
}
function handleKey(event, { onActivate, onBlockEnd, onBlockStart, onDefault, onEnd, onEscape, onHome, onInlineEnd, onInlineStart, onPageDown, onPageUp }) {
  switch (event.keyCode) {
    case KeyCode.down:
      onBlockEnd === null || onBlockEnd === void 0 ? void 0 : onBlockEnd();
      break;
    case KeyCode.end:
      onEnd === null || onEnd === void 0 ? void 0 : onEnd();
      break;
    case KeyCode.enter:
    case KeyCode.space:
      onActivate === null || onActivate === void 0 ? void 0 : onActivate();
      break;
    case KeyCode.escape:
      onEscape === null || onEscape === void 0 ? void 0 : onEscape();
      break;
    case KeyCode.home:
      onHome === null || onHome === void 0 ? void 0 : onHome();
      break;
    case KeyCode.left:
      getIsRtl(event.currentTarget) ? onInlineEnd === null || onInlineEnd === void 0 ? void 0 : onInlineEnd() : onInlineStart === null || onInlineStart === void 0 ? void 0 : onInlineStart();
      break;
    case KeyCode.pageDown:
      onPageDown === null || onPageDown === void 0 ? void 0 : onPageDown();
      break;
    case KeyCode.pageUp:
      onPageUp === null || onPageUp === void 0 ? void 0 : onPageUp();
      break;
    case KeyCode.right:
      getIsRtl(event.currentTarget) ? onInlineStart === null || onInlineStart === void 0 ? void 0 : onInlineStart() : onInlineEnd === null || onInlineEnd === void 0 ? void 0 : onInlineEnd();
      break;
    case KeyCode.up:
      onBlockStart === null || onBlockStart === void 0 ? void 0 : onBlockStart();
      break;
    default:
      onDefault === null || onDefault === void 0 ? void 0 : onDefault();
      break;
  }
}

// node_modules/@cloudscape-design/components/tabs/native-smooth-scroll-supported.js
function native_smooth_scroll_supported_default() {
  return "scrollBehavior" in document.documentElement.style;
}

// node_modules/@cloudscape-design/components/tabs/smooth-scroll.js
var getScrollSpeed = (pixels) => 15e-4 * Math.abs(pixels) + 0.558;
var getScrollTime = (pixels) => Math.round(Math.abs(pixels) / getScrollSpeed(pixels));
var now = () => window.performance ? window.performance.now() : Date.now();
var ease = (k) => {
  return 0.5 * (1 - Math.cos(Math.PI * k));
};
var step = (context) => {
  const time = now();
  const elapsed = Math.min((time - context.startTime) / context.scrollTime, 1);
  const value = ease(elapsed);
  const currentX = context.startX + (context.endX - context.startX) * value;
  context.scrollable.scrollLeft = currentX;
  if (currentX !== context.endX) {
    requestAnimationFrame(() => step(context));
  }
};
var simulateSmoothScroll = (element, endX) => {
  const startX = element.scrollLeft;
  step({
    scrollable: element,
    startX,
    endX,
    startTime: now(),
    scrollTime: getScrollTime(endX - startX)
  });
};
var smoothScroll = (element, to) => {
  if (isMotionDisabled(element)) {
    element.scrollLeft = to;
    return;
  }
  if (native_smooth_scroll_supported_default() && element.scrollTo) {
    element.scrollTo({
      left: to,
      behavior: "smooth"
    });
    return;
  }
  simulateSmoothScroll(element, to);
};
var smooth_scroll_default = smoothScroll;

// node_modules/@cloudscape-design/components/tabs/scroll-utils.js
var onPaginationClick = (headerBarRef, direction) => {
  if (!(headerBarRef === null || headerBarRef === void 0 ? void 0 : headerBarRef.current)) {
    return;
  }
  const element = headerBarRef.current;
  const { scrollLeft, scrollWidth, offsetWidth } = element;
  const paginatedSectionSize = Math.ceil(element.clientWidth * 0.75);
  const scrollDistance = direction === "forward" ? Math.min(Math.abs(scrollLeft) + paginatedSectionSize, scrollWidth - offsetWidth) : Math.max(Math.abs(scrollLeft) - paginatedSectionSize, 0);
  const scrollTo = getIsRtl(element) ? scrollDistance * -1 : scrollDistance;
  smooth_scroll_default(element, scrollTo);
};
var hasHorizontalOverflow = (headerBar, inlineStartOverflowButton) => {
  const { offsetWidth, scrollWidth } = headerBar;
  const paginationButtonsWidth = inlineStartOverflowButton.current && 2 * inlineStartOverflowButton.current.offsetWidth;
  return paginationButtonsWidth ? scrollWidth > offsetWidth + paginationButtonsWidth : scrollWidth > offsetWidth;
};
var hasInlineStartOverflow = (headerBar) => {
  return getScrollInlineStart(headerBar) > 0;
};
var hasInlineEndOverflow = (headerBar) => {
  return Math.ceil(getScrollInlineStart(headerBar)) < headerBar.scrollWidth - headerBar.offsetWidth;
};
var scrollIntoView = (tabHeader, headerBar, smooth = true) => {
  if (!tabHeader || !headerBar) {
    return;
  }
  const margin = 2;
  let updatedLeftScroll = headerBar.scrollLeft;
  updatedLeftScroll = Math.min(updatedLeftScroll, tabHeader.offsetLeft - margin);
  updatedLeftScroll = Math.max(updatedLeftScroll, tabHeader.offsetLeft + tabHeader.offsetWidth / 2 - headerBar.offsetWidth / 2 + margin);
  if (smooth) {
    smooth_scroll_default(headerBar, updatedLeftScroll);
  } else {
    headerBar.scrollLeft = updatedLeftScroll;
  }
};

// node_modules/@cloudscape-design/components/tabs/analytics-metadata/styles.css.js
import "/home/a171157/personal-repos/deep-racer/community-contributions/deepracer-custom-console/new/node_modules/@cloudscape-design/components/tabs/analytics-metadata/styles.scoped.css";
var styles_css_default = {
  "tabs-header-list": "awsui_tabs-header-list_1acwa_dp0cl_5",
  "active-tab-header": "awsui_active-tab-header_1acwa_dp0cl_6",
  "tab-label": "awsui_tab-label_1acwa_dp0cl_7",
  "tab-dismiss-button": "awsui_tab-dismiss-button_1acwa_dp0cl_8"
};

// node_modules/@cloudscape-design/components/tabs/styles.css.js
import "/home/a171157/personal-repos/deep-racer/community-contributions/deepracer-custom-console/new/node_modules/@cloudscape-design/components/tabs/styles.scoped.css";
var styles_css_default2 = {
  "tabs-header": "awsui_tabs-header_14rmt_1ebqu_290",
  "tabs-header-list": "awsui_tabs-header-list_14rmt_1ebqu_298",
  "pagination-button": "awsui_pagination-button_14rmt_1ebqu_316",
  "pagination-button-left": "awsui_pagination-button-left_14rmt_1ebqu_323",
  "pagination-button-left-scrollable": "awsui_pagination-button-left-scrollable_14rmt_1ebqu_326",
  "pagination-button-right": "awsui_pagination-button-right_14rmt_1ebqu_330",
  "pagination-button-right-scrollable": "awsui_pagination-button-right-scrollable_14rmt_1ebqu_333",
  "tabs-tab": "awsui_tabs-tab_14rmt_1ebqu_338",
  "tabs-tab-label": "awsui_tabs-tab-label_14rmt_1ebqu_348",
  "tabs-tab-header-container": "awsui_tabs-tab-header-container_14rmt_1ebqu_359",
  "tabs-tab-dismiss": "awsui_tabs-tab-dismiss_14rmt_1ebqu_370",
  "tabs-tab-action": "awsui_tabs-tab-action_14rmt_1ebqu_370",
  "refresh": "awsui_refresh_14rmt_1ebqu_375",
  "tabs-tab-disabled": "awsui_tabs-tab-disabled_14rmt_1ebqu_379",
  "tabs-tab-link": "awsui_tabs-tab-link_14rmt_1ebqu_421",
  "tabs-tab-active": "awsui_tabs-tab-active_14rmt_1ebqu_499",
  "tabs-header-with-divider": "awsui_tabs-header-with-divider_14rmt_1ebqu_506",
  "tabs-tab-focusable": "awsui_tabs-tab-focusable_14rmt_1ebqu_510",
  "root": "awsui_root_14rmt_1ebqu_514",
  "tabs": "awsui_tabs_14rmt_1ebqu_290",
  "tabs-content": "awsui_tabs-content_14rmt_1ebqu_552",
  "fit-height": "awsui_fit-height_14rmt_1ebqu_556",
  "tabs-content-active": "awsui_tabs-content-active_14rmt_1ebqu_562",
  "tabs-content-wrapper": "awsui_tabs-content-wrapper_14rmt_1ebqu_576",
  "with-paddings": "awsui_with-paddings_14rmt_1ebqu_576",
  "tabs-container-content-wrapper": "awsui_tabs-container-content-wrapper_14rmt_1ebqu_587",
  "disabled-reason-tooltip": "awsui_disabled-reason-tooltip_14rmt_1ebqu_598",
  "tabs-tab-focused": "awsui_tabs-tab-focused_14rmt_1ebqu_602"
};

// node_modules/@cloudscape-design/components/tabs/test-classes/styles.css.js
import "/home/a171157/personal-repos/deep-racer/community-contributions/deepracer-custom-console/new/node_modules/@cloudscape-design/components/tabs/test-classes/styles.scoped.css";
var styles_css_default3 = {
  "tab-dismiss-button": "awsui_tab-dismiss-button_1nq1i_1nd7r_5"
};

// node_modules/@cloudscape-design/components/tabs/tab-header-bar.js
var tabSelector = `.${styles_css_default2["tabs-tab-link"]}`;
var focusedTabSelector = `[role="tab"].${styles_css_default2["tabs-tab-focused"]}`;
var focusableTabSelector = `.${styles_css_default2["tabs-tab-focusable"]}`;
function dismissButton({ dismissLabel, dismissDisabled, onDismiss, tabId }) {
  return import_react.default.createElement(InternalButton, { onClick: onDismiss, variant: "icon", iconName: "close", formAction: "none", ariaLabel: dismissLabel, disabled: dismissDisabled, className: clsx_m_default(styles_css_default3["tab-dismiss-button"], styles_css_default["tab-dismiss-button"]), "data-testid": `awsui-tab-dismiss-button-${tabId}` });
}
function TabHeaderBar({ onChange, activeTabId, tabs, variant, idNamespace, ariaLabel, ariaLabelledby, i18nStrings }) {
  const headerBarRef = (0, import_react.useRef)(null);
  const activeTabHeaderRef = (0, import_react.useRef)(null);
  const inlineStartOverflowButton = (0, import_react.useRef)(null);
  const i18n = useInternalI18n("tabs");
  const isVisualRefresh = useVisualRefresh();
  const containerObjectRef = (0, import_react.useRef)(null);
  const [widthChange, containerMeasureRef] = useContainerQuery((rect) => rect.contentBoxWidth);
  const containerRef = useMergeRefs(containerObjectRef, containerMeasureRef);
  const tabRefs = (0, import_react.useRef)(/* @__PURE__ */ new Map());
  const [horizontalOverflow, setHorizontalOverflow] = (0, import_react.useState)(false);
  const [inlineStartOverflow, setInlineStartOverflow] = (0, import_react.useState)(false);
  const [inlineEndOverflow, setInlineEndOverflow] = (0, import_react.useState)(false);
  const [focusedTabId, setFocusedTabId] = (0, import_react.useState)(activeTabId);
  const [previousActiveTabId, setPreviousActiveTabId] = (0, import_react.useState)(activeTabId);
  const hasActionOrDismissible = tabs.some((tab) => tab.action || tab.dismissible);
  const tabActionAttributes = hasActionOrDismissible ? {
    role: "application",
    "aria-roledescription": i18n("i18nStrings.tabsWithActionsAriaRoleDescription", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.tabsWithActionsAriaRoleDescription)
  } : {
    role: "tablist"
  };
  (0, import_react.useEffect)(() => {
    if (headerBarRef.current) {
      setHorizontalOverflow(hasHorizontalOverflow(headerBarRef.current, inlineStartOverflowButton));
      setInlineStartOverflow(hasInlineStartOverflow(headerBarRef.current));
      setInlineEndOverflow(hasInlineEndOverflow(headerBarRef.current));
    }
  }, [widthChange, tabs]);
  const scrollIntoViewIfPossible = (smooth) => {
    if (!activeTabId) {
      return;
    }
    const activeTabRef = tabRefs.current.get(activeTabId);
    if (activeTabRef && headerBarRef.current) {
      scrollIntoView(activeTabRef, headerBarRef.current, smooth);
    }
  };
  (0, import_react.useEffect)(() => {
    requestAnimationFrame(() => {
      scrollIntoViewIfPossible(false);
    });
  }, [horizontalOverflow, widthChange, tabs.length]);
  (0, import_react.useEffect)(() => {
    scrollIntoViewIfPossible(true);
  }, [activeTabId]);
  (0, import_react.useEffect)(() => {
    var _a, _b;
    if ((_a = headerBarRef.current) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement)) {
      if (document.activeElement !== activeTabHeaderRef.current) {
        (_b = activeTabHeaderRef.current) === null || _b === void 0 ? void 0 : _b.focus({ preventScroll: true });
      }
    }
  }, [activeTabId]);
  const onScroll = () => {
    if (headerBarRef.current) {
      setInlineStartOverflow(hasInlineStartOverflow(headerBarRef.current));
      setInlineEndOverflow(hasInlineEndOverflow(headerBarRef.current));
    }
  };
  const classes = clsx_m_default({
    [styles_css_default2["tabs-header"]]: true,
    [styles_css_default2["tabs-header-with-divider"]]: variant === "default" || isVisualRefresh
  });
  const leftButtonClasses = clsx_m_default({
    [styles_css_default2["pagination-button"]]: true,
    [styles_css_default2["pagination-button-left"]]: true,
    [styles_css_default2["pagination-button-left-scrollable"]]: inlineStartOverflow
  });
  const rightButtonClasses = clsx_m_default({
    [styles_css_default2["pagination-button"]]: true,
    [styles_css_default2["pagination-button-right"]]: true,
    [styles_css_default2["pagination-button-right-scrollable"]]: inlineEndOverflow
  });
  const navigationAPI = (0, import_react.useRef)(null);
  function getNextFocusTarget() {
    var _a, _b;
    if (!containerObjectRef.current) {
      return null;
    }
    const tabElements = Array.from(containerObjectRef.current.querySelectorAll(tabSelector));
    return (_b = (_a = tabElements.find((tab) => tab.matches(focusedTabSelector))) !== null && _a !== void 0 ? _a : tabElements.find((tab) => !tab.disabled)) !== null && _b !== void 0 ? _b : null;
  }
  function onUnregisterActive(focusableElement) {
    var _a;
    const isFocusableActionOrDismissible = !focusableElement.classList.contains(styles_css_default2["tabs-tab-link"]);
    if (!isFocusableActionOrDismissible) {
      const nextFocusTarget = (_a = navigationAPI.current) === null || _a === void 0 ? void 0 : _a.getFocusTarget();
      const tabLinkButton = nextFocusTarget === null || nextFocusTarget === void 0 ? void 0 : nextFocusTarget.querySelector(`.${styles_css_default2["tabs-tab-link"]}`);
      tabLinkButton === null || tabLinkButton === void 0 ? void 0 : tabLinkButton.focus();
    }
  }
  (0, import_react.useEffect)(() => {
    var _a;
    (_a = navigationAPI.current) === null || _a === void 0 ? void 0 : _a.updateFocusTarget();
  });
  function onFocus() {
    var _a;
    (_a = navigationAPI.current) === null || _a === void 0 ? void 0 : _a.updateFocusTarget();
  }
  function onBlur() {
    var _a;
    (_a = navigationAPI.current) === null || _a === void 0 ? void 0 : _a.updateFocusTarget();
  }
  function onKeyDown(event) {
    const focusTarget = document.activeElement;
    const specialKeys = [KeyCode.right, KeyCode.left, KeyCode.end, KeyCode.home, KeyCode.pageUp, KeyCode.pageDown];
    const isActionOpen = document.querySelector(`.${styles_css_default2["tabs-tab-action"]} [aria-expanded="true"]`);
    const isDismissOrActionFocused = !(focusTarget === null || focusTarget === void 0 ? void 0 : focusTarget.classList.contains(styles_css_default2["tabs-tab-link"]));
    if (isActionOpen) {
      return;
    }
    if (event.key === "Tab" && !event.shiftKey && isDismissOrActionFocused) {
      event.preventDefault();
      const panelId = `${idNamespace}-${activeTabId}-panel`;
      const panel = document.getElementById(panelId);
      panel === null || panel === void 0 ? void 0 : panel.focus();
    }
    if (hasModifierKeys(event) || specialKeys.indexOf(event.keyCode) === -1) {
      return;
    }
    if (!containerObjectRef.current || !focusTarget) {
      return;
    }
    event.preventDefault();
    const focusables = getFocusablesFrom(containerObjectRef.current);
    const activeIndex = document.activeElement instanceof HTMLElement ? focusables.indexOf(document.activeElement) : -1;
    handleKey(event, {
      onHome: () => focusElement(focusables[0]),
      onEnd: () => focusElement(focusables[focusables.length - 1]),
      onInlineStart: () => focusElement(focusables[circleIndex(activeIndex - 1, [0, focusables.length - 1])]),
      onInlineEnd: () => focusElement(focusables[circleIndex(activeIndex + 1, [0, focusables.length - 1])]),
      onPageDown: () => inlineEndOverflow && onPaginationClick(headerBarRef, "forward"),
      onPageUp: () => inlineStartOverflow && onPaginationClick(headerBarRef, "backward")
    });
  }
  function focusElement(element) {
    var _a, _b;
    element.focus();
    const tabsById = tabs.reduce((map, tab) => map.set(tab.id, tab), /* @__PURE__ */ new Map());
    for (const [tabId, focusTargetTabTriggerElement] of tabRefs.current.entries()) {
      const focusTargetTabLabelElement = focusTargetTabTriggerElement === null || focusTargetTabTriggerElement === void 0 ? void 0 : focusTargetTabTriggerElement.querySelector(`.${styles_css_default2["tabs-tab-link"]}`);
      if (tabId !== activeTabId && focusTargetTabLabelElement === element) {
        setPreviousActiveTabId(tabId);
        setFocusedTabId(tabId);
        if (!((_a = tabsById.get(tabId)) === null || _a === void 0 ? void 0 : _a.disabled)) {
          onChange({ activeTabId: tabId, activeTabHref: (_b = tabsById.get(tabId)) === null || _b === void 0 ? void 0 : _b.href });
        }
        break;
      }
    }
  }
  function getFocusablesFrom(target) {
    function isElementRegistered(element) {
      var _a, _b;
      return (_b = (_a = navigationAPI.current) === null || _a === void 0 ? void 0 : _a.isRegistered(element)) !== null && _b !== void 0 ? _b : false;
    }
    function isElementFocusable(element) {
      if (element instanceof HTMLButtonElement) {
        return !element.disabled || element.closest(focusableTabSelector);
      }
      return element.matches(focusableTabSelector);
    }
    return getAllFocusables(target).filter((el) => isElementRegistered(el) && isElementFocusable(el));
  }
  const TabList = hasActionOrDismissible ? "div" : "ul";
  return (
    //converted span to div as list should not be a child of span for HTML validation
    import_react.default.createElement(
      "div",
      { className: classes, ref: containerRef },
      horizontalOverflow && import_react.default.createElement(
        "span",
        { ref: inlineStartOverflowButton, className: leftButtonClasses },
        import_react.default.createElement(InternalButton, { formAction: "none", variant: "icon", iconName: "angle-left", disabled: !inlineStartOverflow, __focusable: true, onClick: () => onPaginationClick(headerBarRef, "backward"), ariaLabel: i18n("i18nStrings.scrollLeftAriaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.scrollLeftAriaLabel) })
      ),
      import_react.default.createElement(
        SingleTabStopNavigationProvider,
        { ref: navigationAPI, navigationActive: true, getNextFocusTarget, onUnregisterActive },
        import_react.default.createElement(TabList, Object.assign({}, tabActionAttributes, { className: clsx_m_default(styles_css_default2["tabs-header-list"], styles_css_default["tabs-header-list"]), "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, ref: headerBarRef, onScroll, onKeyDown, onFocus, onBlur }), tabs.map(renderTabHeader))
      ),
      horizontalOverflow && import_react.default.createElement(
        "span",
        { className: rightButtonClasses },
        import_react.default.createElement(InternalButton, { formAction: "none", variant: "icon", iconName: "angle-right", disabled: !inlineEndOverflow, __focusable: true, onClick: () => onPaginationClick(headerBarRef, "forward"), ariaLabel: i18n("i18nStrings.scrollRightAriaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.scrollRightAriaLabel) })
      )
    )
  );
  function renderTabHeader(tab, index) {
    const { dismissible, dismissLabel, dismissDisabled, action, onDismiss } = tab;
    const isActive = activeTabId === tab.id && !tab.disabled;
    const clickTab = (event) => {
      if (tab.disabled) {
        event.preventDefault();
        return;
      }
      const specialKey = !isPlainLeftClick(event);
      if (specialKey && tab.href) {
        return;
      }
      event.preventDefault();
      if (!tab.href) {
        const clickedTabRef = tabRefs.current.get(tab.id);
        if (clickedTabRef) {
          if (clickedTabRef && clickedTabRef !== document.activeElement) {
            clickedTabRef.focus({ preventScroll: true });
          }
        }
      }
      if (tab.id === activeTabId) {
        return;
      }
      setFocusedTabId(tab.id);
      setPreviousActiveTabId(tab.id);
      onChange({ activeTabId: tab.id, activeTabHref: tab.href });
    };
    const classes2 = clsx_m_default({
      [styles_css_default2["tabs-tab-link"]]: true,
      [styles_css_default2.refresh]: isVisualRefresh,
      [styles_css_default2["tabs-tab-active"]]: activeTabId === tab.id && !tab.disabled,
      [styles_css_default2["tabs-tab-focused"]]: focusedTabId === tab.id,
      [styles_css_default2["tabs-tab-active"]]: isActive,
      [styles_css_default["active-tab-header"]]: isActive,
      [styles_css_default2["tabs-tab-disabled"]]: tab.disabled,
      [styles_css_default2["tabs-tab-focusable"]]: !tab.disabled || tab.disabled && !!tab.disabledReason
    });
    const tabHeaderContainerClasses = clsx_m_default({
      [styles_css_default2["tabs-tab-header-container"]]: true,
      [styles_css_default2.refresh]: isVisualRefresh,
      [styles_css_default2["tabs-tab-active"]]: isActive,
      [styles_css_default2["tabs-tab-disabled"]]: tab.disabled,
      [styles_css_default2["tabs-tab-focusable"]]: !tab.disabled || tab.disabled && !!tab.disabledReason
    });
    const tabActionClasses = clsx_m_default({
      [styles_css_default2["tabs-tab-action"]]: true,
      [styles_css_default2["tabs-tab-active"]]: isActive
    });
    const commonProps = {
      className: classes2,
      "aria-controls": `${idNamespace}-${tab.id}-panel`,
      "data-testid": tab.id,
      id: getTabElementId({ namespace: idNamespace, tabId: tab.id }),
      onClick: clickTab
    };
    const tabHeaderContainerAriaProps = hasActionOrDismissible ? {
      role: "group",
      "aria-labelledby": commonProps.id
    } : {};
    if (!hasActionOrDismissible) {
      commonProps["aria-selected"] = activeTabId === tab.id;
      commonProps.role = "tab";
    } else {
      commonProps["aria-expanded"] = activeTabId === tab.id;
    }
    if (tab.disabled) {
      commonProps["aria-disabled"] = "true";
    }
    const setElement = (tabElement) => {
      if (tab.id === activeTabId) {
        activeTabHeaderRef.current = tabElement;
      }
      tabRefs.current.set(tab.id, tabElement);
    };
    const handleDismiss = (event) => {
      if (!containerObjectRef.current || !onDismiss) {
        return;
      }
      const tabElements = getFocusablesFrom(containerObjectRef.current).filter((el) => el.classList.contains(styles_css_default2["tabs-tab-link"]));
      const activeTabIndex = tabElements.findIndex((el) => el.dataset.testid === tab.id);
      tabElements.splice(activeTabIndex, 1);
      let nextActive;
      if (previousActiveTabId && previousActiveTabId !== tab.id) {
        nextActive = tabElements.find((el) => el.dataset.testid === previousActiveTabId);
      } else {
        nextActive = tabElements[Math.min(tabElements.length - 1, activeTabIndex)];
      }
      if (nextActive && nextActive.dataset.testid) {
        onChange({ activeTabId: nextActive.dataset.testid });
        nextActive.focus();
      }
      onDismiss(event);
    };
    const TabItem = hasActionOrDismissible ? "div" : "li";
    const analyticsDismissMetadata = {
      action: "dismiss",
      detail: {
        id: tab.id,
        label: `.${styles_css_default["tab-dismiss-button"]}`,
        position: `${index + 1}`
      }
    };
    const analyticsComponentMetadataInnerContext = {
      innerContext: {
        tabId: tab.id,
        tabLabel: `.${styles_css_default["tab-label"]}`,
        tabPosition: `${index + 1}`
      }
    };
    return import_react.default.createElement(
      TabItem,
      { ref: (element) => tabRefs.current.set(tab.id, element), className: styles_css_default2["tabs-tab"], role: "presentation", key: tab.id },
      import_react.default.createElement(
        "div",
        Object.assign({ className: tabHeaderContainerClasses }, tabHeaderContainerAriaProps, getAnalyticsMetadataAttribute({ component: analyticsComponentMetadataInnerContext })),
        import_react.default.createElement(TabTrigger, { ref: setElement, tab, elementProps: commonProps, activeTabId, index }),
        action && import_react.default.createElement("span", { className: tabActionClasses }, action),
        dismissible && import_react.default.createElement("span", Object.assign({ className: styles_css_default2["tabs-tab-dismiss"] }, getAnalyticsMetadataAttribute(analyticsDismissMetadata)), dismissButton({ dismissLabel, dismissDisabled, onDismiss: handleDismiss, tabId: tab.id }))
      )
    );
  }
}
var TabTrigger = (0, import_react.forwardRef)(({ tab, elementProps, activeTabId, index }, ref) => {
  const refObject = (0, import_react.useRef)(null);
  const tabLabelRefObject = (0, import_react.useRef)(null);
  const mergedRef = useMergeRefs(refObject, ref);
  const { tabIndex } = useSingleTabStopNavigation(refObject);
  const isDisabledWithReason = tab.disabled && !!tab.disabledReason;
  const [showTooltip, setShowTooltip] = (0, import_react.useState)(false);
  const { targetProps, descriptionEl } = useHiddenDescription(tab.disabledReason);
  const children = import_react.default.createElement(
    import_react.default.Fragment,
    null,
    import_react.default.createElement(
      "span",
      { className: clsx_m_default(styles_css_default2["tabs-tab-label"], styles_css_default["tab-label"]), ref: tabLabelRefObject },
      import_react.default.createElement("span", null, tab.label)
    ),
    isDisabledWithReason && import_react.default.createElement(
      import_react.default.Fragment,
      null,
      descriptionEl,
      showTooltip && import_react.default.createElement(Tooltip, { className: styles_css_default2["disabled-reason-tooltip"], trackRef: tabLabelRefObject, value: tab.disabledReason })
    )
  );
  const handlers = {
    onFocus: () => setShowTooltip(true),
    onBlur: () => setShowTooltip(false),
    onMouseEnter: () => setShowTooltip(true),
    onMouseLeave: () => setShowTooltip(false)
  };
  const analyticsSelectMetadata = {
    action: "select",
    detail: {
      id: tab.id,
      label: `.${styles_css_default["tab-label"]}`,
      position: `${index + 1}`,
      originTabId: activeTabId || ""
    }
  };
  const commonProps = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, elementProps), isDisabledWithReason ? targetProps : {}), isDisabledWithReason ? handlers : {}), { ref: mergedRef, tabIndex }), tab.disabled || tab.id === activeTabId ? {} : getAnalyticsMetadataAttribute(analyticsSelectMetadata));
  return tab.href ? import_react.default.createElement("a", Object.assign({}, commonProps, { href: tab.href }), children) : import_react.default.createElement("button", Object.assign({}, commonProps, { type: "button", disabled: tab.disabled && !isDisabledWithReason }), children);
});
function getTabElementId({ namespace, tabId }) {
  return namespace + "-" + tabId;
}

// node_modules/@cloudscape-design/components/tabs/index.js
function firstEnabledTab(tabs) {
  const enabledTabs = tabs.filter((tab) => !tab.disabled);
  if (enabledTabs.length > 0) {
    return enabledTabs[0];
  }
  return null;
}
function Tabs(_a) {
  var _b, _c;
  var { tabs, variant = "default", onChange, activeTabId: controlledTabId, ariaLabel, ariaLabelledby, disableContentPaddings = false, i18nStrings, fitHeight } = _a, rest = __rest(_a, ["tabs", "variant", "onChange", "activeTabId", "ariaLabel", "ariaLabelledby", "disableContentPaddings", "i18nStrings", "fitHeight"]);
  for (const tab of tabs) {
    checkSafeUrl("Tabs", tab.href);
  }
  const { __internalRootRef } = useBaseComponent("Tabs", {
    props: { disableContentPaddings, variant, fitHeight },
    metadata: {
      hasActions: tabs.some((tab) => !!tab.action),
      hasDisabledReasons: tabs.some((tab) => !!tab.disabledReason)
    }
  });
  const idNamespace = useUniqueId("awsui-tabs-");
  const [activeTabId, setActiveTabId] = useControllable(controlledTabId, onChange, (_c = (_b = firstEnabledTab(tabs)) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : "", {
    componentName: "Tabs",
    controlledProp: "activeTabId",
    changeHandler: "onChange"
  });
  const baseProps = getBaseProps(rest);
  const analyticsComponentMetadata = {
    name: "awsui.Tabs",
    label: `.${styles_css_default["tabs-header-list"]}`
  };
  if (activeTabId) {
    analyticsComponentMetadata.properties = {
      activeTabId,
      activeTabLabel: `.${styles_css_default["active-tab-header"]} .${styles_css_default["tab-label"]}`,
      activeTabPosition: `${tabs.findIndex((tab) => tab.id === activeTabId) + 1}`,
      tabsCount: `${tabs.length}`
    };
  }
  const content = () => {
    const selectedTab = tabs.filter((tab) => tab.id === activeTabId)[0];
    const renderContent = (tab) => {
      const isTabSelected = tab === selectedTab;
      const classes = clsx_m_default({
        [styles_css_default2["tabs-content"]]: true,
        [styles_css_default2["tabs-content-active"]]: isTabSelected
      });
      const contentAttributes = {
        className: classes,
        role: "tabpanel",
        id: `${idNamespace}-${tab.id}-panel`,
        key: `${idNamespace}-${tab.id}-panel`,
        tabIndex: 0,
        "aria-labelledby": getTabElementId({ namespace: idNamespace, tabId: tab.id })
      };
      const isContentShown = isTabSelected && !selectedTab.disabled;
      return import_react2.default.createElement("div", Object.assign({}, contentAttributes), isContentShown && selectedTab.content);
    };
    return import_react2.default.createElement("div", { className: clsx_m_default(variant === "container" || variant === "stacked" ? styles_css_default2["tabs-container-content-wrapper"] : styles_css_default2["tabs-content-wrapper"], {
      [styles_css_default2["with-paddings"]]: !disableContentPaddings
    }) }, tabs.map(renderContent));
  };
  const header = import_react2.default.createElement(TabHeaderBar, { activeTabId, variant, idNamespace, ariaLabel, ariaLabelledby, tabs, onChange: (changeDetail) => {
    setActiveTabId(changeDetail.activeTabId);
    fireNonCancelableEvent(onChange, changeDetail);
  }, i18nStrings });
  if (variant === "container" || variant === "stacked") {
    return import_react2.default.createElement(InternalContainer, Object.assign({ header, disableHeaderPaddings: true }, baseProps, { className: clsx_m_default(baseProps.className, styles_css_default2.root), __internalRootRef, disableContentPaddings: true, variant: variant === "stacked" ? "stacked" : "default", fitHeight }, getAnalyticsMetadataAttribute({ component: analyticsComponentMetadata })), content());
  }
  return import_react2.default.createElement(
    "div",
    Object.assign({}, baseProps, { className: clsx_m_default(baseProps.className, styles_css_default2.root, styles_css_default2.tabs, { [styles_css_default2["fit-height"]]: fitHeight }), ref: __internalRootRef }, getAnalyticsMetadataAttribute({ component: analyticsComponentMetadata })),
    header,
    content()
  );
}
applyDisplayName(Tabs, "Tabs");

export {
  useControllable,
  isEventLike,
  handleKey,
  circleIndex,
  Tabs
};
//# sourceMappingURL=chunk-UAJBG4XP.js.map
