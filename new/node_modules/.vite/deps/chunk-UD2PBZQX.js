import {
  nodeBelongs
} from "./chunk-IF2JLTU2.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@cloudscape-design/components/internal/context/single-tab-stop-navigation-context.js
var import_react = __toESM(require_react());
var defaultValue = {
  navigationActive: false,
  registerFocusable: () => () => {
  }
};
var SingleTabStopNavigationContext = (0, import_react.createContext)(defaultValue);
function useSingleTabStopNavigation(focusable, options) {
  var _a;
  const { navigationActive: contextNavigationActive, registerFocusable } = (0, import_react.useContext)(SingleTabStopNavigationContext);
  const [focusTargetActive, setFocusTargetActive] = (0, import_react.useState)(false);
  const navigationDisabled = (options === null || options === void 0 ? void 0 : options.tabIndex) && (options === null || options === void 0 ? void 0 : options.tabIndex) < 0;
  const navigationActive = contextNavigationActive && !navigationDisabled;
  (0, import_react.useLayoutEffect)(() => {
    if (navigationActive && focusable && focusable.current) {
      const unregister = registerFocusable(focusable.current, (isFocusable) => setFocusTargetActive(isFocusable));
      return () => unregister();
    }
  });
  let tabIndex = options === null || options === void 0 ? void 0 : options.tabIndex;
  if (navigationActive) {
    tabIndex = !focusTargetActive ? -1 : (_a = options === null || options === void 0 ? void 0 : options.tabIndex) !== null && _a !== void 0 ? _a : 0;
  }
  return { navigationActive, tabIndex };
}
var SingleTabStopNavigationProvider = (0, import_react.forwardRef)(({ navigationActive, children, getNextFocusTarget, isElementSuppressed, onRegisterFocusable, onUnregisterActive }, ref) => {
  const focusables = (0, import_react.useRef)(/* @__PURE__ */ new Set());
  const focusHandlers = (0, import_react.useRef)(/* @__PURE__ */ new Map());
  const focusablesState = (0, import_react.useRef)(/* @__PURE__ */ new WeakMap());
  const focusTarget = (0, import_react.useRef)(null);
  function onUnregisterFocusable(focusableElement) {
    const isUnregisteringFocusedNode = nodeBelongs(focusableElement, document.activeElement);
    if (isUnregisteringFocusedNode) {
      setTimeout(() => onUnregisterActive === null || onUnregisterActive === void 0 ? void 0 : onUnregisterActive(focusableElement), 0);
    }
  }
  function registerFocusable(focusableElement, changeHandler) {
    focusables.current.add(focusableElement);
    focusHandlers.current.set(focusableElement, changeHandler);
    const isFocusable = !!focusablesState.current.get(focusableElement);
    const newIsFocusable = focusTarget.current === focusableElement || !!(isElementSuppressed === null || isElementSuppressed === void 0 ? void 0 : isElementSuppressed(focusableElement));
    if (newIsFocusable !== isFocusable) {
      focusablesState.current.set(focusableElement, newIsFocusable);
      changeHandler(newIsFocusable);
    }
    onRegisterFocusable === null || onRegisterFocusable === void 0 ? void 0 : onRegisterFocusable(focusableElement);
    return () => unregisterFocusable(focusableElement);
  }
  function unregisterFocusable(focusableElement) {
    focusables.current.delete(focusableElement);
    focusHandlers.current.delete(focusableElement);
    onUnregisterFocusable === null || onUnregisterFocusable === void 0 ? void 0 : onUnregisterFocusable(focusableElement);
  }
  function updateFocusTarget() {
    var _a;
    focusTarget.current = getNextFocusTarget();
    for (const focusableElement of focusables.current) {
      const isFocusable = (_a = focusablesState.current.get(focusableElement)) !== null && _a !== void 0 ? _a : false;
      const newIsFocusable = focusTarget.current === focusableElement || !!(isElementSuppressed === null || isElementSuppressed === void 0 ? void 0 : isElementSuppressed(focusableElement));
      if (newIsFocusable !== isFocusable) {
        focusablesState.current.set(focusableElement, newIsFocusable);
        focusHandlers.current.get(focusableElement)(newIsFocusable);
      }
    }
  }
  function getFocusTarget() {
    return focusTarget.current;
  }
  function isRegistered(element) {
    return focusables.current.has(element);
  }
  (0, import_react.useImperativeHandle)(ref, () => ({ updateFocusTarget, getFocusTarget, isRegistered }));
  return import_react.default.createElement(SingleTabStopNavigationContext.Provider, { value: { navigationActive, registerFocusable } }, children);
});

export {
  defaultValue,
  SingleTabStopNavigationContext,
  useSingleTabStopNavigation,
  SingleTabStopNavigationProvider
};
//# sourceMappingURL=chunk-UD2PBZQX.js.map
