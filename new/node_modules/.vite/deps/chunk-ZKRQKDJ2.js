import {
  custom_css_properties_default,
  getOverflowParents,
  getScrollInlineStart,
  isDevelopment,
  isRtl,
  useContainerQuery,
  useInternalI18n,
  useMobile
} from "./chunk-B6KLV4PV.js";
import {
  InternalButton,
  checkSafeUrl,
  findUpUntil,
  fireNonCancelableEvent,
  hasModifierKeys,
  isPlainLeftClick,
  supportsStickyPosition,
  useFunnelSubStep,
  useMergeRefs,
  useUniqueId
} from "./chunk-3NPYXGPE.js";
import {
  KeyCode,
  __rest,
  applyDisplayName,
  clsx_m_default,
  getBaseProps,
  isMotionDisabled,
  useBaseComponent,
  useResizeObserver,
  useVisualRefresh,
  warnOnce
} from "./chunk-ZJSKJ6UY.js";
import {
  require_react
} from "./chunk-WHMHD7EJ.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@cloudscape-design/components/tabs/index.js
var import_react9 = __toESM(require_react());

// node_modules/@cloudscape-design/components/container/internal.js
var import_react7 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/context/app-layout-context.js
var import_react = __toESM(require_react());
var defaultValue = {
  stickyOffsetTop: 0,
  stickyOffsetBottom: 0,
  mobileBarHeight: 0
};
var AppLayoutContext = (0, import_react.createContext)(defaultValue);
function useAppLayoutContext() {
  return (0, import_react.useContext)(AppLayoutContext);
}

// node_modules/@cloudscape-design/components/internal/utils/global-flags.js
var awsuiGlobalFlagsSymbol = Symbol.for("awsui-global-flags");
var getTopWindow = () => {
  return window.top;
};
function getGlobal() {
  return typeof window !== "undefined" ? window : globalThis;
}
function readFlag(window2, flagName) {
  var _a;
  const holder = window2;
  return (_a = holder === null || holder === void 0 ? void 0 : holder[awsuiGlobalFlagsSymbol]) === null || _a === void 0 ? void 0 : _a[flagName];
}
var getGlobalFlag = (flagName) => {
  try {
    const ownFlag = readFlag(getGlobal(), flagName);
    if (ownFlag !== void 0) {
      return ownFlag;
    }
    return readFlag(getTopWindow(), flagName);
  } catch (e) {
    return void 0;
  }
};

// node_modules/@cloudscape-design/components/internal/utils/content-header-utils.js
var shouldRemoveHighContrastHeader = () => !!getGlobalFlag("removeHighContrastHeader");
var getContentHeaderClassName = () => shouldRemoveHighContrastHeader() ? "" : "awsui-context-content-header";

// node_modules/@cloudscape-design/components/container/use-sticky-header.js
var import_react2 = __toESM(require_react());
function computeOffset({ isMobile, isVisualRefresh, customCssProps, __stickyOffset, __mobileStickyOffset, mobileBarHeight = 0, stickyOffsetTop, hasInnerOverflowParents }) {
  const effectiveStickyOffset = __stickyOffset !== null && __stickyOffset !== void 0 ? __stickyOffset : hasInnerOverflowParents ? 0 : stickyOffsetTop;
  let computedOffset = `${effectiveStickyOffset}px`;
  if (isMobile) {
    const classicOffset = `${stickyOffsetTop + mobileBarHeight + (__stickyOffset !== null && __stickyOffset !== void 0 ? __stickyOffset : 0) - (__mobileStickyOffset !== null && __mobileStickyOffset !== void 0 ? __mobileStickyOffset : 0)}px`;
    const visualRefreshOffset = `calc(var(${customCssProps.offsetTop}, 0px) + var(${customCssProps.mobileBarHeight}, 0px) + ${(__stickyOffset !== null && __stickyOffset !== void 0 ? __stickyOffset : 0) - (__mobileStickyOffset !== null && __mobileStickyOffset !== void 0 ? __mobileStickyOffset : 0)}px)`;
    computedOffset = isVisualRefresh ? visualRefreshOffset : classicOffset;
  } else if (isVisualRefresh && !hasInnerOverflowParents) {
    computedOffset = `var(${customCssProps.offsetTopWithNotifications}, ${computedOffset})`;
  }
  return computedOffset;
}
var StickyHeaderContext = (0, import_react2.createContext)({
  isStuck: false
});
var useStickyHeader = (rootRef, headerRef, __stickyHeader, __stickyOffset, __mobileStickyOffset, __disableMobile = true) => {
  const isMobile = useMobile();
  const { stickyOffsetTop, mobileBarHeight } = useAppLayoutContext();
  const disableSticky = isMobile && __disableMobile;
  const isSticky = supportsStickyPosition() && !disableSticky && !!__stickyHeader;
  const isVisualRefresh = useVisualRefresh();
  const [hasInnerOverflowParents, setHasInnerOverflowParents] = (0, import_react2.useState)(false);
  const [isStuck, setIsStuck] = (0, import_react2.useState)(false);
  (0, import_react2.useLayoutEffect)(() => {
    if (rootRef.current) {
      const overflowParents = getOverflowParents(rootRef.current);
      const mainElement = findUpUntil(rootRef.current, (elem) => elem.tagName === "MAIN");
      setHasInnerOverflowParents(overflowParents.length > 0 && overflowParents[0] !== mainElement);
    }
  }, [rootRef]);
  const computedOffset = computeOffset({
    isMobile,
    isVisualRefresh,
    customCssProps: custom_css_properties_default,
    __stickyOffset,
    __mobileStickyOffset,
    mobileBarHeight,
    stickyOffsetTop,
    hasInnerOverflowParents
  });
  const stickyStyles = isSticky ? {
    style: {
      top: computedOffset
    }
  } : {};
  const checkIfStuck = (0, import_react2.useCallback)(() => {
    if (rootRef.current && headerRef.current) {
      const rootTopBorderWidth = parseFloat(getComputedStyle(rootRef.current).borderTopWidth) || 0;
      const rootTop = rootRef.current.getBoundingClientRect().top + rootTopBorderWidth;
      const headerTop = headerRef.current.getBoundingClientRect().top;
      if (rootTop < headerTop) {
        setIsStuck(true);
      } else {
        setIsStuck(false);
      }
    }
  }, [rootRef, headerRef]);
  (0, import_react2.useEffect)(() => {
    if (isSticky) {
      window.addEventListener("scroll", checkIfStuck, true);
      window.addEventListener("resize", checkIfStuck);
      return () => {
        window.removeEventListener("scroll", checkIfStuck, true);
        window.removeEventListener("resize", checkIfStuck);
      };
    }
  }, [isSticky, checkIfStuck]);
  return {
    isSticky,
    isStuck,
    stickyStyles
  };
};

// node_modules/@cloudscape-design/components/internal/hooks/use-dynamic-overlap/index.js
var import_react4 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/context/dynamic-overlap-context.js
var import_react3 = __toESM(require_react());
var DynamicOverlapContext = (0, import_react3.createContext)(() => {
});

// node_modules/@cloudscape-design/components/internal/hooks/use-dynamic-overlap/index.js
var import_react5 = __toESM(require_react());
function useDynamicOverlap(props) {
  var _a;
  const disabled = (_a = props === null || props === void 0 ? void 0 : props.disabled) !== null && _a !== void 0 ? _a : false;
  const setDynamicOverlapHeight = (0, import_react4.useContext)(DynamicOverlapContext);
  const overlapElementRef = (0, import_react5.useRef)(null);
  const getElement = (0, import_react5.useCallback)(() => overlapElementRef.current, [overlapElementRef]);
  const updateState = (0, import_react5.useCallback)((entry) => {
    if (!disabled) {
      setDynamicOverlapHeight(entry.contentBoxHeight);
    }
  }, [disabled, setDynamicOverlapHeight]);
  useResizeObserver(getElement, updateState);
  (0, import_react4.useLayoutEffect)(function handleDynamicOverlapHeight() {
    return () => {
      if (!disabled) {
        setDynamicOverlapHeight(0);
      }
    };
  }, [disabled, setDynamicOverlapHeight]);
  return overlapElementRef;
}

// node_modules/@cloudscape-design/components/container/styles.css.js
import "/home/a171157/personal-repos/deep-racer/community-contributions/deepracer-custom-console/new/node_modules/@cloudscape-design/components/container/styles.scoped.css";
var styles_css_default = {
  "root": "awsui_root_14iqq_v4tpg_103",
  "fit-height": "awsui_fit-height_14iqq_v4tpg_139",
  "with-side-media": "awsui_with-side-media_14iqq_v4tpg_144",
  "variant-default": "awsui_variant-default_14iqq_v4tpg_147",
  "variant-stacked": "awsui_variant-stacked_14iqq_v4tpg_147",
  "refresh": "awsui_refresh_14iqq_v4tpg_155",
  "sticky-enabled": "awsui_sticky-enabled_14iqq_v4tpg_205",
  "with-top-media": "awsui_with-top-media_14iqq_v4tpg_217",
  "content-wrapper": "awsui_content-wrapper_14iqq_v4tpg_222",
  "content-wrapper-fit-height": "awsui_content-wrapper-fit-height_14iqq_v4tpg_227",
  "media": "awsui_media_14iqq_v4tpg_234",
  "media-top": "awsui_media-top_14iqq_v4tpg_252",
  "media-side": "awsui_media-side_14iqq_v4tpg_257",
  "header": "awsui_header_14iqq_v4tpg_263",
  "header-with-media": "awsui_header-with-media_14iqq_v4tpg_268",
  "header-sticky-disabled": "awsui_header-sticky-disabled_14iqq_v4tpg_274",
  "header-sticky-enabled": "awsui_header-sticky-enabled_14iqq_v4tpg_278",
  "header-stuck": "awsui_header-stuck_14iqq_v4tpg_284",
  "header-variant-cards": "awsui_header-variant-cards_14iqq_v4tpg_294",
  "header-dynamic-height": "awsui_header-dynamic-height_14iqq_v4tpg_297",
  "with-paddings": "awsui_with-paddings_14iqq_v4tpg_303",
  "with-hidden-content": "awsui_with-hidden-content_14iqq_v4tpg_312",
  "header-variant-full-page": "awsui_header-variant-full-page_14iqq_v4tpg_370",
  "remove-high-contrast-header": "awsui_remove-high-contrast-header_14iqq_v4tpg_390",
  "dark-header": "awsui_dark-header_14iqq_v4tpg_399",
  "content": "awsui_content_14iqq_v4tpg_222",
  "content-fit-height": "awsui_content-fit-height_14iqq_v4tpg_407",
  "content-with-media": "awsui_content-with-media_14iqq_v4tpg_417",
  "footer": "awsui_footer_14iqq_v4tpg_421",
  "with-divider": "awsui_with-divider_14iqq_v4tpg_425"
};

// node_modules/@cloudscape-design/components/internal/context/modal-context.js
var import_react6 = __toESM(require_react());
var ModalContext = (0, import_react6.createContext)({ isInModal: false });
var useModalContext = () => {
  const modalContext = (0, import_react6.useContext)(ModalContext);
  return modalContext;
};

// node_modules/@cloudscape-design/components/container/internal.js
function InternalContainerAsSubstep(props) {
  const { subStepRef, funnelSubStepProps } = useFunnelSubStep();
  const modalContext = useModalContext();
  return import_react7.default.createElement(InternalContainer, Object.assign({}, props, { __subStepRef: (modalContext === null || modalContext === void 0 ? void 0 : modalContext.isInModal) ? { current: null } : subStepRef, __funnelSubStepProps: (modalContext === null || modalContext === void 0 ? void 0 : modalContext.isInModal) ? {} : funnelSubStepProps }));
}
function InternalContainer(_a) {
  var _b;
  var { header, footer, children, variant = "default", disableHeaderPaddings = false, disableContentPaddings = false, fitHeight, media, __stickyOffset, __mobileStickyOffset, __stickyHeader = false, __internalRootRef = null, __disableFooterDivider = false, __disableFooterPaddings = false, __hiddenContent = false, __headerRef, __darkHeader = false, __disableStickyMobile = true, __funnelSubStepProps, __subStepRef } = _a, restProps = __rest(_a, ["header", "footer", "children", "variant", "disableHeaderPaddings", "disableContentPaddings", "fitHeight", "media", "__stickyOffset", "__mobileStickyOffset", "__stickyHeader", "__internalRootRef", "__disableFooterDivider", "__disableFooterPaddings", "__hiddenContent", "__headerRef", "__darkHeader", "__disableStickyMobile", "__funnelSubStepProps", "__subStepRef"]);
  const isMobile = useMobile();
  const baseProps = getBaseProps(restProps);
  const rootRef = (0, import_react7.useRef)(null);
  const headerRef = (0, import_react7.useRef)(null);
  const { isSticky, isStuck, stickyStyles } = useStickyHeader(rootRef, headerRef, __stickyHeader, __stickyOffset, __mobileStickyOffset, __disableStickyMobile);
  const contentId = useUniqueId();
  const { setHasStickyBackground } = useAppLayoutContext();
  const isRefresh = useVisualRefresh();
  const hasDynamicHeight = isRefresh && variant === "full-page";
  const overlapElement = useDynamicOverlap({ disabled: !hasDynamicHeight || !__darkHeader });
  const mergedRef = useMergeRefs(rootRef, __internalRootRef);
  const headerMergedRef = useMergeRefs(headerRef, overlapElement, __headerRef);
  (0, import_react7.useEffect)(() => {
    const shouldUpdateStickyBackground = isSticky && variant === "full-page" && setHasStickyBackground;
    if (shouldUpdateStickyBackground) {
      setHasStickyBackground(true);
    }
    return () => {
      if (shouldUpdateStickyBackground) {
        setHasStickyBackground(false);
      }
    };
  }, [isSticky, setHasStickyBackground, variant]);
  const shouldHaveStickyStyles = isSticky && !isMobile;
  const hasMedia = !!(media === null || media === void 0 ? void 0 : media.content);
  const mediaPosition = (_b = media === null || media === void 0 ? void 0 : media.position) !== null && _b !== void 0 ? _b : "top";
  return import_react7.default.createElement(
    "div",
    Object.assign({}, baseProps, __funnelSubStepProps, { className: clsx_m_default(baseProps.className, styles_css_default.root, styles_css_default[`variant-${variant}`], fitHeight && styles_css_default["fit-height"], hasMedia && (mediaPosition === "side" ? styles_css_default["with-side-media"] : styles_css_default["with-top-media"]), shouldHaveStickyStyles && [styles_css_default["sticky-enabled"]], isRefresh && styles_css_default.refresh), ref: mergedRef }),
    hasMedia && import_react7.default.createElement("div", { className: clsx_m_default(styles_css_default[`media-${mediaPosition === "side" ? "side" : "top"}`], styles_css_default.media), style: mediaPosition === "top" ? { height: (media === null || media === void 0 ? void 0 : media.height) || "" } : { width: (media === null || media === void 0 ? void 0 : media.width) || "" } }, media.content),
    import_react7.default.createElement(
      "div",
      { id: contentId, ref: __subStepRef, className: clsx_m_default(styles_css_default["content-wrapper"], fitHeight && styles_css_default["content-wrapper-fit-height"]) },
      header && import_react7.default.createElement(
        StickyHeaderContext.Provider,
        { value: { isStuck } },
        import_react7.default.createElement("div", Object.assign({ className: clsx_m_default(isRefresh && styles_css_default.refresh, styles_css_default.header, styles_css_default[`header-variant-${variant}`], shouldRemoveHighContrastHeader() && styles_css_default["remove-high-contrast-header"], {
          [styles_css_default["header-sticky-disabled"]]: __stickyHeader && !isSticky,
          [styles_css_default["header-sticky-enabled"]]: isSticky,
          [styles_css_default["header-dynamic-height"]]: hasDynamicHeight,
          [styles_css_default["header-stuck"]]: isStuck,
          [styles_css_default["with-paddings"]]: !disableHeaderPaddings,
          [styles_css_default["with-hidden-content"]]: !children || __hiddenContent,
          [styles_css_default["header-with-media"]]: hasMedia
        }) }, stickyStyles, { ref: headerMergedRef }), __darkHeader ? import_react7.default.createElement("div", { className: clsx_m_default(styles_css_default["dark-header"], getContentHeaderClassName()) }, header) : header)
      ),
      import_react7.default.createElement("div", { className: clsx_m_default(styles_css_default.content, fitHeight && styles_css_default["content-fit-height"], shouldRemoveHighContrastHeader() && styles_css_default["remove-high-contrast-header"], {
        [styles_css_default["with-paddings"]]: !disableContentPaddings
      }) }, children),
      footer && import_react7.default.createElement("div", { className: clsx_m_default(styles_css_default.footer, {
        [styles_css_default["with-divider"]]: !__disableFooterDivider,
        [styles_css_default["with-paddings"]]: !__disableFooterPaddings
      }) }, footer)
    )
  );
}

// node_modules/@cloudscape-design/components/tabs/styles.css.js
import "/home/a171157/personal-repos/deep-racer/community-contributions/deepracer-custom-console/new/node_modules/@cloudscape-design/components/tabs/styles.scoped.css";
var styles_css_default2 = {
  "tabs-header": "awsui_tabs-header_14rmt_n8497_198",
  "tabs-header-list": "awsui_tabs-header-list_14rmt_n8497_206",
  "pagination-button": "awsui_pagination-button_14rmt_n8497_223",
  "pagination-button-left": "awsui_pagination-button-left_14rmt_n8497_230",
  "pagination-button-left-scrollable": "awsui_pagination-button-left-scrollable_14rmt_n8497_233",
  "pagination-button-right": "awsui_pagination-button-right_14rmt_n8497_237",
  "pagination-button-right-scrollable": "awsui_pagination-button-right-scrollable_14rmt_n8497_240",
  "tabs-tab": "awsui_tabs-tab_14rmt_n8497_245",
  "tabs-tab-label": "awsui_tabs-tab-label_14rmt_n8497_257",
  "tabs-tab-link": "awsui_tabs-tab-link_14rmt_n8497_273",
  "refresh": "awsui_refresh_14rmt_n8497_292",
  "tabs-tab-disabled": "awsui_tabs-tab-disabled_14rmt_n8497_343",
  "tabs-tab-active": "awsui_tabs-tab-active_14rmt_n8497_378",
  "tabs-header-with-divider": "awsui_tabs-header-with-divider_14rmt_n8497_385",
  "root": "awsui_root_14rmt_n8497_389",
  "tabs": "awsui_tabs_14rmt_n8497_198",
  "tabs-content": "awsui_tabs-content_14rmt_n8497_430",
  "fit-height": "awsui_fit-height_14rmt_n8497_434",
  "tabs-content-active": "awsui_tabs-content-active_14rmt_n8497_440",
  "tabs-content-wrapper": "awsui_tabs-content-wrapper_14rmt_n8497_454",
  "with-paddings": "awsui_with-paddings_14rmt_n8497_454",
  "tabs-container-content-wrapper": "awsui_tabs-container-content-wrapper_14rmt_n8497_465"
};

// node_modules/@cloudscape-design/components/tabs/tab-header-bar.js
var import_react8 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/utils/handle-key.js
function handleKey(event, { onActivate, onBlockEnd, onBlockStart, onEnd, onHome, onInlineEnd, onInlineStart, onPageDown, onPageUp }) {
  switch (event.keyCode) {
    case KeyCode.down:
      onBlockEnd === null || onBlockEnd === void 0 ? void 0 : onBlockEnd();
      break;
    case KeyCode.end:
      onEnd === null || onEnd === void 0 ? void 0 : onEnd();
      break;
    case KeyCode.enter:
    case KeyCode.space:
      onActivate === null || onActivate === void 0 ? void 0 : onActivate();
      break;
    case KeyCode.home:
      onHome === null || onHome === void 0 ? void 0 : onHome();
      break;
    case KeyCode.left:
      isRtl(event.currentTarget) ? onInlineEnd === null || onInlineEnd === void 0 ? void 0 : onInlineEnd() : onInlineStart === null || onInlineStart === void 0 ? void 0 : onInlineStart();
      break;
    case KeyCode.pageDown:
      onPageDown === null || onPageDown === void 0 ? void 0 : onPageDown();
      break;
    case KeyCode.pageUp:
      onPageUp === null || onPageUp === void 0 ? void 0 : onPageUp();
      break;
    case KeyCode.right:
      isRtl(event.currentTarget) ? onInlineStart === null || onInlineStart === void 0 ? void 0 : onInlineStart() : onInlineEnd === null || onInlineEnd === void 0 ? void 0 : onInlineEnd();
      break;
    case KeyCode.up:
      onBlockStart === null || onBlockStart === void 0 ? void 0 : onBlockStart();
      break;
  }
}

// node_modules/@cloudscape-design/components/tabs/native-smooth-scroll-supported.js
function native_smooth_scroll_supported_default() {
  return "scrollBehavior" in document.documentElement.style;
}

// node_modules/@cloudscape-design/components/tabs/smooth-scroll.js
var getScrollSpeed = (pixels) => 15e-4 * Math.abs(pixels) + 0.558;
var getScrollTime = (pixels) => Math.round(Math.abs(pixels) / getScrollSpeed(pixels));
var now = () => window.performance ? window.performance.now() : Date.now();
var ease = (k) => {
  return 0.5 * (1 - Math.cos(Math.PI * k));
};
var step = (context) => {
  const time = now();
  const elapsed = Math.min((time - context.startTime) / context.scrollTime, 1);
  const value = ease(elapsed);
  const currentX = context.startX + (context.endX - context.startX) * value;
  context.scrollable.scrollLeft = currentX;
  if (currentX !== context.endX) {
    requestAnimationFrame(() => step(context));
  }
};
var simulateSmoothScroll = (element, endX) => {
  const startX = element.scrollLeft;
  step({
    scrollable: element,
    startX,
    endX,
    startTime: now(),
    scrollTime: getScrollTime(endX - startX)
  });
};
var smoothScroll = (element, to) => {
  if (isMotionDisabled(element)) {
    element.scrollLeft = to;
    return;
  }
  if (native_smooth_scroll_supported_default() && element.scrollTo) {
    element.scrollTo({
      left: to,
      behavior: "smooth"
    });
    return;
  }
  simulateSmoothScroll(element, to);
};
var smooth_scroll_default = smoothScroll;

// node_modules/@cloudscape-design/components/tabs/scroll-utils.js
var onPaginationClick = (headerBarRef, direction) => {
  if (!(headerBarRef === null || headerBarRef === void 0 ? void 0 : headerBarRef.current)) {
    return;
  }
  const element = headerBarRef.current;
  const { scrollLeft, scrollWidth, offsetWidth } = element;
  const paginatedSectionSize = Math.ceil(element.clientWidth * 0.75);
  const scrollDistance = direction === "forward" ? Math.min(Math.abs(scrollLeft) + paginatedSectionSize, scrollWidth - offsetWidth) : Math.max(Math.abs(scrollLeft) - paginatedSectionSize, 0);
  const scrollTo = isRtl(element) ? scrollDistance * -1 : scrollDistance;
  smooth_scroll_default(element, scrollTo);
};
var hasHorizontalOverflow = (headerBar, inlineStartOverflowButton) => {
  const { offsetWidth, scrollWidth } = headerBar;
  const paginationButtonsWidth = inlineStartOverflowButton.current && 2 * inlineStartOverflowButton.current.offsetWidth;
  return paginationButtonsWidth ? scrollWidth > offsetWidth + paginationButtonsWidth : scrollWidth > offsetWidth;
};
var hasInlineStartOverflow = (headerBar) => {
  return getScrollInlineStart(headerBar) > 0;
};
var hasInlineEndOverflow = (headerBar) => {
  return Math.ceil(getScrollInlineStart(headerBar)) < headerBar.scrollWidth - headerBar.offsetWidth;
};
var scrollIntoView = (tabHeader, headerBar, smooth = true) => {
  if (!tabHeader || !headerBar) {
    return;
  }
  const margin = 2;
  let updatedLeftScroll = headerBar.scrollLeft;
  updatedLeftScroll = Math.min(updatedLeftScroll, tabHeader.offsetLeft - margin);
  updatedLeftScroll = Math.max(updatedLeftScroll, tabHeader.offsetLeft + tabHeader.offsetWidth - headerBar.offsetWidth + margin);
  if (smooth) {
    smooth_scroll_default(headerBar, updatedLeftScroll);
  } else {
    headerBar.scrollLeft = updatedLeftScroll;
  }
};

// node_modules/@cloudscape-design/components/tabs/tab-header-bar.js
function TabHeaderBar({ onChange, activeTabId, tabs, variant, idNamespace, ariaLabel, ariaLabelledby, i18nStrings }) {
  const headerBarRef = (0, import_react8.useRef)(null);
  const activeTabHeaderRef = (0, import_react8.useRef)(null);
  const inlineStartOverflowButton = (0, import_react8.useRef)(null);
  const i18n = useInternalI18n("tabs");
  const isVisualRefresh = useVisualRefresh();
  const [widthChange, containerRef] = useContainerQuery((rect) => rect.contentBoxWidth);
  const tabRefs = (0, import_react8.useRef)(/* @__PURE__ */ new Map());
  const [horizontalOverflow, setHorizontalOverflow] = (0, import_react8.useState)(false);
  const [inlineStartOverflow, setInlineStartOverflow] = (0, import_react8.useState)(false);
  const [inlineEndOverflow, setInlineEndOverflow] = (0, import_react8.useState)(false);
  (0, import_react8.useEffect)(() => {
    if (headerBarRef.current) {
      setHorizontalOverflow(hasHorizontalOverflow(headerBarRef.current, inlineStartOverflowButton));
      setInlineStartOverflow(hasInlineStartOverflow(headerBarRef.current));
      setInlineEndOverflow(hasInlineEndOverflow(headerBarRef.current));
    }
  }, [widthChange, tabs]);
  const scrollIntoViewIfPossible = (smooth) => {
    if (!activeTabId) {
      return;
    }
    const activeTabRef = tabRefs.current.get(activeTabId);
    if (activeTabRef && headerBarRef.current) {
      scrollIntoView(activeTabRef, headerBarRef.current, smooth);
    }
  };
  (0, import_react8.useEffect)(() => {
    requestAnimationFrame(() => {
      scrollIntoViewIfPossible(false);
    });
  }, [horizontalOverflow, widthChange, tabs.length]);
  (0, import_react8.useEffect)(() => {
    scrollIntoViewIfPossible(true);
  }, [activeTabId]);
  (0, import_react8.useEffect)(() => {
    var _a, _b;
    if ((_a = headerBarRef.current) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement)) {
      if (document.activeElement !== activeTabHeaderRef.current) {
        (_b = activeTabHeaderRef.current) === null || _b === void 0 ? void 0 : _b.focus({ preventScroll: true });
      }
    }
  }, [activeTabId]);
  const onScroll = () => {
    if (headerBarRef.current) {
      setInlineStartOverflow(hasInlineStartOverflow(headerBarRef.current));
      setInlineEndOverflow(hasInlineEndOverflow(headerBarRef.current));
    }
  };
  const classes = clsx_m_default({
    [styles_css_default2["tabs-header"]]: true,
    [styles_css_default2["tabs-header-with-divider"]]: variant === "default" || isVisualRefresh
  });
  const leftButtonClasses = clsx_m_default({
    [styles_css_default2["pagination-button"]]: true,
    [styles_css_default2["pagination-button-left"]]: true,
    [styles_css_default2["pagination-button-left-scrollable"]]: inlineStartOverflow
  });
  const rightButtonClasses = clsx_m_default({
    [styles_css_default2["pagination-button"]]: true,
    [styles_css_default2["pagination-button-right"]]: true,
    [styles_css_default2["pagination-button-right-scrollable"]]: inlineEndOverflow
  });
  return (
    //converted span to div as list should not be a child of span for HTML validation
    import_react8.default.createElement(
      "div",
      { className: classes, ref: containerRef },
      horizontalOverflow && import_react8.default.createElement(
        "span",
        { ref: inlineStartOverflowButton, className: leftButtonClasses },
        import_react8.default.createElement(InternalButton, { formAction: "none", variant: "icon", iconName: "angle-left", disabled: !inlineStartOverflow, __focusable: true, onClick: () => onPaginationClick(headerBarRef, "backward"), ariaLabel: i18n("i18nStrings.scrollLeftAriaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.scrollLeftAriaLabel) })
      ),
      import_react8.default.createElement("ul", { role: "tablist", className: styles_css_default2["tabs-header-list"], "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, ref: headerBarRef, onScroll }, tabs.map(renderTabHeader)),
      horizontalOverflow && import_react8.default.createElement(
        "span",
        { className: rightButtonClasses },
        import_react8.default.createElement(InternalButton, { formAction: "none", variant: "icon", iconName: "angle-right", disabled: !inlineEndOverflow, __focusable: true, onClick: () => onPaginationClick(headerBarRef, "forward"), ariaLabel: i18n("i18nStrings.scrollRightAriaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.scrollRightAriaLabel) })
      )
    )
  );
  function renderTabHeader(tab) {
    const enabledTabsWithCurrentTab = tabs.filter((tab2) => !tab2.disabled || tab2.id === activeTabId);
    const highlightTab = function(enabledTabIndex) {
      const tab2 = enabledTabsWithCurrentTab[enabledTabIndex];
      if (tab2.id === activeTabId) {
        return;
      }
      onChange({ activeTabId: tab2.id, activeTabHref: tab2.href });
    };
    const onKeyDown = function(event) {
      const { keyCode } = event;
      const specialKeys = [KeyCode.right, KeyCode.left, KeyCode.end, KeyCode.home, KeyCode.pageUp, KeyCode.pageDown];
      if (hasModifierKeys(event) || specialKeys.indexOf(keyCode) === -1) {
        return;
      }
      event.preventDefault();
      const activeIndex = enabledTabsWithCurrentTab.indexOf(tab);
      handleKey(event, {
        onEnd: () => highlightTab(enabledTabsWithCurrentTab.length - 1),
        onHome: () => highlightTab(0),
        onInlineEnd: () => activeIndex + 1 === enabledTabsWithCurrentTab.length ? highlightTab(0) : highlightTab(activeIndex + 1),
        onInlineStart: () => activeIndex === 0 ? highlightTab(enabledTabsWithCurrentTab.length - 1) : highlightTab(activeIndex - 1),
        onPageDown: () => inlineEndOverflow && onPaginationClick(headerBarRef, "forward"),
        onPageUp: () => inlineStartOverflow && onPaginationClick(headerBarRef, "backward")
      });
    };
    const clickTab = (event) => {
      if (tab.disabled) {
        event.preventDefault();
        return;
      }
      const specialKey = !isPlainLeftClick(event);
      if (specialKey && tab.href) {
        return;
      }
      event.preventDefault();
      if (!tab.href) {
        const clickedTabRef = tabRefs.current.get(tab.id);
        if (clickedTabRef) {
          const childElement = clickedTabRef.firstChild;
          if (childElement && childElement !== document.activeElement) {
            childElement.focus({ preventScroll: true });
          }
        }
      }
      if (tab.id === activeTabId) {
        return;
      }
      onChange({ activeTabId: tab.id, activeTabHref: tab.href });
    };
    const classes2 = clsx_m_default({
      [styles_css_default2["tabs-tab-link"]]: true,
      [styles_css_default2.refresh]: isVisualRefresh,
      [styles_css_default2["tabs-tab-active"]]: activeTabId === tab.id && !tab.disabled,
      [styles_css_default2["tabs-tab-disabled"]]: tab.disabled
    });
    const commonProps = {
      className: classes2,
      role: "tab",
      "aria-selected": tab.id === activeTabId,
      "aria-controls": `${idNamespace}-${tab.id}-panel`,
      "data-testid": tab.id,
      id: getTabElementId({ namespace: idNamespace, tabId: tab.id }),
      children: import_react8.default.createElement("span", { className: styles_css_default2["tabs-tab-label"] }, tab.label)
    };
    if (tab.disabled) {
      commonProps["aria-disabled"] = "true";
    } else {
      commonProps.onClick = clickTab;
    }
    if (tab.id === activeTabId) {
      commonProps.ref = activeTabHeaderRef;
      commonProps.tabIndex = 0;
      commonProps.onKeyDown = (event) => onKeyDown(event);
    } else {
      commonProps.tabIndex = -1;
    }
    let trigger = null;
    if (tab.href) {
      const anchorProps = commonProps;
      anchorProps.href = tab.href;
      trigger = import_react8.default.createElement("a", Object.assign({}, anchorProps));
    } else {
      const buttonProps = commonProps;
      buttonProps.type = "button";
      if (tab.disabled) {
        buttonProps.disabled = true;
      }
      trigger = import_react8.default.createElement("button", Object.assign({}, buttonProps));
    }
    return import_react8.default.createElement("li", { ref: (element) => tabRefs.current.set(tab.id, element), className: styles_css_default2["tabs-tab"], role: "presentation", key: tab.id }, trigger);
  }
}
function getTabElementId({ namespace, tabId }) {
  return namespace + "-" + tabId;
}

// node_modules/@cloudscape-design/components/internal/hooks/use-controllable/index.js
var React3 = __toESM(require_react());
function useControllable(controlledValue, handler, defaultValue2, { componentName, changeHandler, controlledProp }) {
  const isControlled = React3.useState(controlledValue !== void 0)[0];
  if (isDevelopment) {
    React3.useEffect(() => {
      if (isControlled && handler === void 0) {
        warnOnce(componentName, `You provided a \`${controlledProp}\` prop without an \`${changeHandler}\` handler. This will render a non-interactive component.`);
      }
    }, [handler, isControlled, componentName, changeHandler, controlledProp]);
    React3.useEffect(() => {
      const isControlledNow = controlledValue !== void 0;
      if (isControlled !== isControlledNow) {
        const initialMode = isControlled ? "controlled" : "uncontrolled";
        const modeNow = isControlledNow ? "controlled" : "uncontrolled";
        warnOnce(componentName, `A component tried to change ${initialMode} '${controlledProp}' property to be ${modeNow}. This is not supported. Properties should not switch from ${initialMode} to ${modeNow} (or vice versa). Decide between using a controlled or uncontrolled mode for the lifetime of the component. More info: https://fb.me/react-controlled-components`);
      }
    }, [isControlled, controlledProp, componentName, controlledValue]);
  }
  const [valueState, setValue] = React3.useState(defaultValue2);
  const [valueHasBeenSet, setValueHasBeenSet] = React3.useState(false);
  const currentUncontrolledValue = valueHasBeenSet ? valueState : defaultValue2;
  const setUncontrolledValue = React3.useCallback((newValue) => {
    setValue(newValue);
    setValueHasBeenSet(true);
  }, [setValue, setValueHasBeenSet]);
  if (isControlled) {
    return [controlledValue, defaultCallback];
  } else {
    return [currentUncontrolledValue, setUncontrolledValue];
  }
}
function defaultCallback() {
  return void 0;
}

// node_modules/@cloudscape-design/components/tabs/index.js
function firstEnabledTab(tabs) {
  const enabledTabs = tabs.filter((tab) => !tab.disabled);
  if (enabledTabs.length > 0) {
    return enabledTabs[0];
  }
  return null;
}
function Tabs(_a) {
  var _b, _c;
  var { tabs, variant = "default", onChange, activeTabId: controlledTabId, ariaLabel, ariaLabelledby, disableContentPaddings = false, i18nStrings, fitHeight } = _a, rest = __rest(_a, ["tabs", "variant", "onChange", "activeTabId", "ariaLabel", "ariaLabelledby", "disableContentPaddings", "i18nStrings", "fitHeight"]);
  for (const tab of tabs) {
    checkSafeUrl("Tabs", tab.href);
  }
  const { __internalRootRef } = useBaseComponent("Tabs", {
    props: { disableContentPaddings, variant }
  });
  const idNamespace = useUniqueId("awsui-tabs-");
  const [activeTabId, setActiveTabId] = useControllable(controlledTabId, onChange, (_c = (_b = firstEnabledTab(tabs)) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : "", {
    componentName: "Tabs",
    controlledProp: "activeTabId",
    changeHandler: "onChange"
  });
  const baseProps = getBaseProps(rest);
  const content = () => {
    const selectedTab = tabs.filter((tab) => tab.id === activeTabId)[0];
    const renderContent = (tab) => {
      const isTabSelected = tab === selectedTab;
      const classes = clsx_m_default({
        [styles_css_default2["tabs-content"]]: true,
        [styles_css_default2["tabs-content-active"]]: isTabSelected
      });
      const contentAttributes = {
        className: classes,
        role: "tabpanel",
        id: `${idNamespace}-${tab.id}-panel`,
        key: `${idNamespace}-${tab.id}-panel`,
        tabIndex: 0,
        "aria-labelledby": getTabElementId({ namespace: idNamespace, tabId: tab.id })
      };
      const isContentShown = isTabSelected && !selectedTab.disabled;
      return import_react9.default.createElement("div", Object.assign({}, contentAttributes), isContentShown && selectedTab.content);
    };
    return import_react9.default.createElement("div", { className: clsx_m_default(variant === "container" || variant === "stacked" ? styles_css_default2["tabs-container-content-wrapper"] : styles_css_default2["tabs-content-wrapper"], {
      [styles_css_default2["with-paddings"]]: !disableContentPaddings
    }) }, tabs.map(renderContent));
  };
  const header = import_react9.default.createElement(TabHeaderBar, { activeTabId, variant, idNamespace, ariaLabel, ariaLabelledby, tabs, onChange: (changeDetail) => {
    setActiveTabId(changeDetail.activeTabId);
    fireNonCancelableEvent(onChange, changeDetail);
  }, i18nStrings });
  if (variant === "container" || variant === "stacked") {
    return import_react9.default.createElement(InternalContainer, Object.assign({ header, disableHeaderPaddings: true }, baseProps, { className: clsx_m_default(baseProps.className, styles_css_default2.root), __internalRootRef, disableContentPaddings: true, variant: variant === "stacked" ? "stacked" : "default", fitHeight }), content());
  }
  return import_react9.default.createElement(
    "div",
    Object.assign({}, baseProps, { className: clsx_m_default(baseProps.className, styles_css_default2.root, styles_css_default2.tabs, { [styles_css_default2["fit-height"]]: fitHeight }), ref: __internalRootRef }),
    header,
    content()
  );
}
applyDisplayName(Tabs, "Tabs");

export {
  getGlobalFlag,
  useControllable,
  defaultValue,
  AppLayoutContext,
  useAppLayoutContext,
  DynamicOverlapContext,
  shouldRemoveHighContrastHeader,
  getContentHeaderClassName,
  StickyHeaderContext,
  useDynamicOverlap,
  ModalContext,
  InternalContainerAsSubstep,
  InternalContainer,
  handleKey,
  Tabs
};
//# sourceMappingURL=chunk-ZKRQKDJ2.js.map
